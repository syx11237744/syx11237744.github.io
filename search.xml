<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NLP</title>
    <url>/2024/10/03/NLP/</url>
    <content><![CDATA[<h3 id="三类不同的transformer模型">三类不同的Transformer模型：</h3>
<ul>
<li>GPT-like(自回归)</li>
<li>BERT-like（自动编码）</li>
<li>BART/T5-like（seq2seq）</li>
</ul>
<p>要执行微调需要获取一个经过预训练的预言模型，然后使用特定于任务的数据集执行额外的训练，之所以不在最后的任务训练是因为：</p>
<ul>
<li><p>利用模型在预训练期间获得的知识</p></li>
<li><p>避免过拟合 <span id="more"></span> ### 模型块：</p></li>
<li><p>Encoder:编码器接收输入并构建其表示（其特征）</p></li>
<li><p>Decoder:解码器使用编码器的表示（特征）以及其他输入来生成目标序列。</p></li>
</ul>
<p>这些部件可以根据任务独立使用：</p>
<ul>
<li><strong>Encoder-only models</strong>:
适用于需要理解输入的任务，如句子分类和命名实体识别。</li>
<li><strong>Decoder-only models</strong>:
适用于生成任务，如文本生成。</li>
<li><strong>Encoder-decoder models</strong> 或者
<strong>sequence-to-sequence models</strong>:
适用于需要根据输入进行生成的任务，如翻译或摘要。</li>
</ul>
<h3 id="原始结构">原始结构</h3>
<p>Encoder中的注意力层可以看到一个句子中的所有单词，但Decoder只能看到之前的单词，为了加快训练速度，会把整个目标输入，但是不允许获取到之后的单词</p>
<p>解码器块中的第一个注意力层关联到解码器的所有（过去的）输入，但是第二注意力层使用编码器的输出。因此，它可以访问整个输入句子，以最好地预测当前单词。</p>
<figure>
<img
src="/Users/sunyuanxu/Library/Application%20Support/typora-user-images/image-20240906171929209.png"
alt="image-20240906171929209" />
<figcaption aria-hidden="true">image-20240906171929209</figcaption>
</figure>
<h3 id="编码器模型">编码器模型</h3>
<p>仅使用编码器的Transformer模型，在每个阶段，注意力层都可以获取初始句子中的所有单词。这些模型通常具有“双向”注意力，被称为自编码模型。“双向注意力”通常指的是在模型中使用的注意力机制，能够在处理输入序列时同时考虑前后文的信息。</p>
<h3 id="解码器模型">解码器模型</h3>
<p>“解码器”模型通常指仅使用解码器的Transformer模型。在每个阶段，对于给定的单词，注意力层只能获取到句子中位于将要预测单词前面的单词。这些模型通常被称为自回归模型。“解码器”模型的预训练通常围绕预测句子中的下一个单词进行。这些模型最适合于涉及文本生成的任务。</p>
<h3 id="seq2seq模型">seq2seq模型</h3>
<p>编码器-解码器模型（也称为序列到序列模型)同时使用Transformer架构的编码器和解码器两个部分。在每个阶段，编码器的注意力层可以访问初始句子中的所有单词，而解码器的注意力层只能访问位于输入中将要预测单词前面的单词。这些模型的预训练可以使用训练编码器或解码器模型的方式来完成，但通常涉及更复杂的内容。例如，<a
href="https://huggingface.co/t5-base">T5</a>通过将文本的随机跨度（可以包含多个单词）替换为单个特殊单词来进行预训练，然后目标是预测该掩码单词替换的文本。序列到序列模型最适合于围绕根据给定输入生成新句子的任务，如摘要、翻译或生成性问答。</p>
<figure>
<img
src="/Users/sunyuanxu/Library/Application%20Support/typora-user-images/image-20240906172528917.png"
alt="image-20240906172528917" />
<figcaption aria-hidden="true">image-20240906172528917</figcaption>
</figure>
<h3 id="模型头">模型头</h3>
<figure>
<img
src="/Users/sunyuanxu/Library/Application%20Support/typora-user-images/image-20240907152633126.png"
alt="image-20240907152633126" />
<figcaption aria-hidden="true">image-20240907152633126</figcaption>
</figure>
<p>模型头将hidden
states的输出作为输入，并将其投影到不同的维度。它们通常有一个或几个线性层组成。</p>
<h3 id="对输出进行后处理">对输出进行后处理</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(outputs.logits)</span><br><span class="line">tensor([[-1.5607,  1.6123],</span><br><span class="line">        [ 4.1692, -3.3464]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure>
<p>输出不是概率，而是logits，即模型最后一层输出的原始非标准化分数，概率是经过一个SoftMax层</p>
]]></content>
  </entry>
  <entry>
    <title>RL学习笔记</title>
    <url>/2024/10/03/RL/</url>
    <content><![CDATA[<h2 id="markov-decision-process-mdp">Markov Decision Process (MDP)</h2>
<h3 id="马尔可夫过程">1. 马尔可夫过程</h3>
<p>通常用元组 <span class="math inline">\(⟨S,P⟩\)</span>
描述一个马尔可夫过程，其中 <span class="math inline">\(S\)</span>
为有限数量的状态集合，<span class="math inline">\(P\)</span>
是状态转移矩阵：</p>
<p><span class="math display">\[
P = \begin{bmatrix}
P(s_1|s_1) &amp; \cdots &amp; P(s_n|s_1) \\
\vdots &amp; \ddots &amp; \vdots \\
P(s_1|s_n) &amp; \cdots &amp; P(s_n|s_n)
\end{bmatrix}
\]</span></p>
<p>对于状态转移矩阵，每一行的和都是
1。直观地理解，每个状态一定会到下一个状态，那么把所有可能到达的状态的概率求和，就为
1。 <span id="more"></span> ### 2. 马尔可夫奖励过程</p>
<p>在马尔可夫过程中加入奖励函数 <span class="math inline">\(r\)</span>
和折扣因子 <span
class="math inline">\(\gamma\)</span>，就可以得到马尔可夫奖励过程（Markov
Reward Process）。一个马尔可夫奖励过程由 <span class="math inline">\((S,
P, r, \gamma)\)</span> 构成，各个组成元素的含义如下：</p>
<ul>
<li><span class="math inline">\(S\)</span> 是有限状态的集合。</li>
<li><span class="math inline">\(P\)</span> 是状态转移矩阵。</li>
<li><span class="math inline">\(r\)</span> 是奖励函数，某个状态 <span
class="math inline">\(s\)</span> 的奖励 <span
class="math inline">\(r(s)\)</span>
指转移到该状态时可以获得奖励的期望。</li>
<li><span class="math inline">\(\gamma\)</span> 是折扣因子（discount
factor），<span class="math inline">\(\gamma\)</span> 的取值范围为 [0,
1)。引入折扣因子的理由为远期利益具有一定不确定性，有时我们更希望能够尽快获得一些奖励，所以我们需要对远期利益打一些折扣。接近
1 的 <span class="math inline">\(\gamma\)</span>
更关注长期的累计奖励，接近 0 的 <span
class="math inline">\(\gamma\)</span> 更考虑短期奖励。</li>
</ul>
<h4 id="回报">2.1 回报</h4>
<p><span class="math display">\[
G_t = R_t + \gamma R_{t+1} + \gamma^2 R_{t+2} + \cdots =
\sum_{k=0}^\infty \gamma^k R_{t+k}
\]</span></p>
<p>其中，<span class="math inline">\(R_t\)</span> 表示在时刻 <span
class="math inline">\(t\)</span> 获得的奖励。</p>
<h4 id="价值函数">2.2 价值函数</h4>
<p>一个状态的期望回报（即从这个状态出发的未来累积奖励的期望）被称为这个状态的价值（value），价值函数的定义
<span class="math inline">\(V(s) = \mathbb{E}[G_t \mid S_t =
s]\)</span>，展开为：</p>
<p><span class="math display">\[
V(s) = \mathbb{E}[G_t \mid S_t = s]
= \mathbb{E}[R_t + \gamma R_{t+1} + \gamma^2 R_{t+2} + \cdots \mid S_t =
s]
= \mathbb{E}[R_t + \gamma G_{t+1} \mid S_t = s]
= \mathbb{E}[R_t \mid S_t = s] + \gamma \mathbb{E}[G_{t+1} \mid S_t = s]
= r(s) + \gamma \mathbb{E}[V(S_{t+1}) \mid S_t = s]
\]</span></p>
<p><span class="math inline">\(\mathbb{E}[R_t \mid S_t = s] =
r(s)\)</span>；另一方面，等式中剩余部分 <span
class="math inline">\(\mathbb{E}[\gamma V(S_{t+1}) \mid S_t =
s]\)</span> 可以根据从状态 <span class="math inline">\(s\)</span>
出发的转移概率得到，即可以得到：</p>
<p><span class="math display">\[
V(s) = r(s) + \gamma \sum_{s&#39; \in S} p(s&#39; \mid s)V(s&#39;)
\]</span></p>
<p>上面就是贝尔曼方程（Bellman
Equation）。将贝尔曼方程写成矩阵的形式：</p>
<p><span class="math display">\[
\mathbf{V} = \mathbf{R} + \gamma \mathbf{P} \mathbf{V}
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
V(s_1) \\
V(s_2) \\
\vdots \\
V(s_n)
\end{bmatrix}
=
\begin{bmatrix}
r(s_1) \\
r(s_2) \\
\vdots \\
r(s_n)
\end{bmatrix}
+
\gamma
\begin{bmatrix}
p(s_1 \mid s_1) &amp; \cdots &amp; p(s_n \mid s_1) \\
p(s_1 \mid s_2) &amp; \cdots &amp; p(s_n \mid s_2) \\
\vdots &amp; \ddots &amp; \vdots \\
p(s_1 \mid s_n) &amp; \cdots &amp; p(s_n \mid s_n)
\end{bmatrix}
\begin{bmatrix}
V(s_1) \\
V(s_2) \\
\vdots \\
V(s_n)
\end{bmatrix}
\]</span></p>
<p>我们可以直接根据矩阵运算求解，得到以下解析解：</p>
<p><span class="math display">\[
\mathbf{V} = (\mathbf{I} - \gamma \mathbf{P})^{-1} \mathbf{R}
\]</span></p>
<h3 id="马尔可夫决策过程">3. 马尔可夫决策过程</h3>
<p>上面的过程都是自发的，对于 MP 过程是基于概率自发的，对于 MRP
过程基于概率和累积奖励自发，对于马尔可夫决策过程（Markov Decision
Process,
MDP），他接受来自外界的刺激，称作<strong>智能体的动作</strong>。与 MRP
的过程十分相似，只是多了一个动作的变量，具体而言，由 <span
class="math inline">\(⟨S,A,P,r,\lambda⟩\)</span> 构成：</p>
<ul>
<li><span class="math inline">\(S\)</span> 是状态的集合</li>
<li><span class="math inline">\(A\)</span> 是动作的集合</li>
<li><span class="math inline">\(\lambda\)</span> 是折扣因子</li>
<li><span class="math inline">\(r(s,a)\)</span> 是奖励函数</li>
<li><span class="math inline">\(P(s&#39; \mid s,a)\)</span>
是状态转移函数，表示在 <span class="math inline">\(s\)</span>
状态执行动作 <span class="math inline">\(a\)</span> 之后到达状态 <span
class="math inline">\(s&#39;\)</span> 的概率</li>
</ul>
<h4 id="策略">3.1 策略</h4>
<p>智能体的策略 (Policy) 通常使用 <span
class="math inline">\(\pi\)</span> 来表示。<span
class="math inline">\(\pi(a \mid s)=P(A_t=a \mid S_t=s)\)</span>
是一个函数，表示在输入状态 <span class="math inline">\(s\)</span>
情况下采取动作 <span class="math inline">\(a\)</span>
的概率。分为确定性策略（对于一个状态之后只会执行一个特定的动作）和随机性策略（对于一个状态会得到的是一个概率分布）。</p>
<h4 id="状态价值函数">3.2 状态价值函数</h4>
<p><span class="math inline">\(V^{\pi}(s)=E_{\pi}[G_t \mid
S_t=s]\)</span> 定义为从状态 <span class="math inline">\(s\)</span>
出发，按照策略 <span class="math inline">\(\pi\)</span>
能获得的期望回报。</p>
<h4 id="动作价值函数">3.3 动作价值函数</h4>
<p><span class="math inline">\(Q^{\pi}(s,a)=E_{\pi}[G_t \mid S_t=s,
A_t=a]\)</span> 表示在 MDP 遵循策略 <span
class="math inline">\(\pi\)</span> 的时候，对于当前动作 <span
class="math inline">\(s\)</span> 执行动作 <span
class="math inline">\(a\)</span> 得到的期望回报。</p>
<p>由全概率公式可以得到：</p>
<p><span class="math display">\[
V^{\pi}(s)=\sum_{a\in A}\pi(a \mid s)Q^{\pi}(s,a)
\]</span></p>
<p>类似于 MRP，可以得到下面的公式：</p>
<p><span class="math display">\[
Q^{\pi}(s,a)=E_{\pi}[R_t+\lambda Q^{\pi}(S_{t+1},A_{t+1}) \mid
S_t=s,A_t=a]
\]</span></p>
<p><span class="math display">\[
=r(s,a)+\lambda \sum_{s&#39;\in S}(p(s&#39; \mid s,a)\sum_{a&#39;\in
A}\pi(a&#39; \mid s&#39;)Q^{\pi}(s&#39;,a&#39;))
\]</span></p>
<h4 id="贝尔曼期望方程">3.4 贝尔曼期望方程</h4>
<p><span class="math display">\[
V^{\pi}(s)=E_{\pi}[G_t \mid S_t=s]=\sum_{a\in A}\left(\pi(a \mid
s)\left(r(s,a)+\lambda\sum_{s&#39;}p(s&#39; \mid
s,a)V^{\pi}(s&#39;)\right)\right)
\]</span></p>
<p><span class="math display">\[
Q^{\pi}(s,a)=r(s,a)+\lambda \sum_{s&#39;\in S}\left(p(s&#39; \mid
s,a)\sum_{a&#39;\in A}\pi(a&#39; \mid
s&#39;)Q^{\pi}(s&#39;,a&#39;)\right)
\]</span></p>
<h4 id="占用度量">3.5 占用度量</h4>
<p>首先，我们定义 MDP 的初始状态分布 <span
class="math inline">\(V_0(s)\)</span>，用 <span
class="math inline">\(P_t^{\pi}\)</span> 表示采取策略 <span
class="math inline">\(\pi\)</span> 使得智能体在 <span
class="math inline">\(t\)</span> 时刻状态为 <span
class="math inline">\(s\)</span>
的概率，我们可以定义一个状态访问分布（它描述了在整个时间过程中，智能体有多大概率访问到某个特定状态）：</p>
<p><span class="math display">\[
v^{\pi}(s)=(1-\lambda)\sum_{t=0}^{\infty}\lambda^{t}P_t^{\pi}(s)
\]</span></p>
<p>此外，我们还可以定义策略的占用度量（occupancy measure）：</p>
<p><span class="math display">\[
\rho^\pi(s, a) = (1 - \gamma) \sum_{t=0}^{\infty} \gamma^t P_t^\pi(s)
\pi(a \mid s)
\]</span></p>
<p>它表示动作状态对 <span class="math inline">\((s, a)\)</span>
被访问到的概率。二者之间存在如下关系：</p>
<p><span class="math display">\[
\rho^\pi(s, a) = v^\pi(s) \pi(a \mid s)
\]</span></p>
<p>进一步得出如下两个定理。<strong>定理 1</strong>：智能体分别以策略
<span class="math inline">\(\pi_1\)</span> 和 <span
class="math inline">\(\pi_2\)</span> 和同一个 MDP 交互得到的占用度量
<span class="math inline">\(\rho^{\pi_1}\)</span> 和 <span
class="math inline">\(\rho^{\pi_2}\)</span> 满足：</p>
<p><span class="math display">\[
\rho^{\pi_1} = \rho^{\pi_2} \iff \pi_1 = \pi_2
\]</span></p>
<p><strong>定理 2</strong>：给定一个合法占用度量 <span
class="math inline">\(\rho\)</span>，可生成该占用度量的唯一策略是：</p>
<p><span class="math display">\[
\pi_\rho = \frac{\rho(s, a)}{\sum_{a&#39;} \rho(s, a&#39;)}
\]</span></p>
<h4 id="最优策略">3.6 最优策略</h4>
<p>强化学习的目标通常是找到一个策略，使得智能体从初始状态出发能获得最多的期望回报。我们首先定义策略之间的偏序关系：当且仅当对于任意的状态
<span class="math inline">\(s\)</span> 都有 <span
class="math inline">\(V^{\pi&#39;}(s) \ge V^\pi(s)\)</span> 时，记 <span
class="math inline">\(\pi&#39; \succeq
\pi\)</span>。于是存在有限状态和动作集合的 MDP
中，至少存在一个策略比其他所有策略都好或者至少不差于其他所有策略，这个策略就是最优策略（optimal
policy）。最优策略可能有很多个，我们都将其表示为 <span
class="math inline">\(\pi^*\)</span>。</p>
<p>最优策略都有相同的状态价值函数，我们称之为<strong>最优状态价值函数</strong>，表示为：</p>
<p><span class="math display">\[
V^*(s) = \max_\pi V^\pi(s), \quad \forall s \in S
\]</span></p>
<p>同理，我们定义<strong>最优动作价值函数</strong>为：</p>
<p><span class="math display">\[
Q^*(s, a) = \max_\pi Q^\pi(s, a), \quad \forall s \in S, a \in A
\]</span></p>
<p>为了使 <span class="math inline">\(Q^\pi(s, a)\)</span>
最大，我们需要在当前的状态动作对 <span class="math inline">\((s,
a)\)</span>
之后都执行最优策略。于是我们得到了最优状态价值函数和最优动作价值函数之间的关系：</p>
<p><span class="math display">\[
Q^*(s, a) = r(s, a) + \gamma \sum_{s&#39; \in S} P(s&#39; \mid s, a)
V^*(s&#39;)
\]</span></p>
<p>这与在普通策略下的状态价值函数和动作价值函数之间的关系是一样的。另一方面，最优状态价值是选择使得最优动作价值最大的那个动作时的状态价值：</p>
<p><span class="math display">\[
V^*(s) = \max_{a \in A} Q^*(s, a)
\]</span></p>
<h4 id="贝尔曼最优方程">3.7 贝尔曼最优方程</h4>
<p>根据 <span class="math inline">\(V^*(s)\)</span> 和 <span
class="math inline">\(Q^*(s, a)\)</span>
的关系，我们可以得到<strong>贝尔曼最优方程</strong>（Bellman Optimality
Equation）：</p>
<p><span class="math display">\[
V^*(s) = \max_{a \in A} \{ r(s, a) + \gamma \sum_{s&#39; \in S} p(s&#39;
\mid s, a) V^*(s&#39;) \}
\]</span></p>
<p><span class="math display">\[
Q^*(s, a) = r(s, a) + \gamma \sum_{s&#39; \in S} P(s&#39; \mid s, a)
\max_{a&#39; \in A} Q^*(s&#39;, a&#39;)
\]</span></p>
<h2 id="动态规划算法">动态规划算法</h2>
<h3 id="策略迭代算法">1. 策略迭代算法</h3>
<h4 id="策略评估">1.1 策略评估</h4>
<p>随机选定<span
class="math inline">\(V^0\)</span>,在贝尔曼期望期望方程上迭代： <span
class="math display">\[
V^{k+1}(s)=\sum_{a\in A}\pi(a|s)\left(r(s|a)+\gamma\sum_{s&#39;\in
S}P(s&#39;|s,a)V^k(s&#39;) \right)
\]</span> （数学原理可以保证这个的成立）</p>
<h4 id="策略提升">1.2 策略提升</h4>
<p>使用完全贪心的策略,直接贪心的在每个状态选择动作价值最大的那个动作
<span class="math display">\[
\pi&#39;(s)=arg max_aQ^{\pi}(s,a)
\]</span></p>
<h4 id="策略迭代算法-1">1.3 策略迭代算法</h4>
<p>对当前的策略进行策略评估，得到其状态价值函数，然后根据该状态价值函数进行策略提升以得到一个更好的新策略，接着继续评估新策略、提升策略……直至最后收敛到最优策略</p>
<h4 id="价值迭代算法">1.4 价值迭代算法</h4>
<p>在贝尔曼最优方程上进行迭代 <span class="math display">\[
V^{k+1}(s)=max_{a\in A}\{r(s|a)+\gamma\sum_{s&#39;\in
S}P(s&#39;|s,a)V^k(s&#39;)\}
\]</span></p>
<h2 id="时序差分算法">时序差分算法</h2>
<p><strong>无模型的强化学习</strong>：对于大部分的强化学习现实场景，环境的奖励函数和状态转移函数是未知的，因此智能体只能通过和环境进行交互，通过采样到的数据进行学习</p>
<h3 id="时序差分方法">1. 时序差分方法</h3>
<h4 id="增量更新">1.1增量更新：</h4>
<p><span class="math display">\[
\begin{aligned}
Q_k &amp;= \frac{1}{k} \sum_{i=1}^k r_i \\
&amp;= \frac{1}{k} \left( r_k + \sum_{i=1}^{k-1} r_i \right) \\
&amp;= \frac{1}{k} \left( r_k + (k-1)Q_{k-1} \right) \\
&amp;= \frac{1}{k} \left( r_k + kQ_{k-1} - Q_{k-1} \right) \\
&amp;= Q_{k-1} + \frac{1}{k} \left[ r_k - Q_{k-1} \right]
\end{aligned}
\]</span></p>
<p>把<span
class="math inline">\(Q_k\)</span>是一种平均值，假设我们的<span
class="math inline">\(r_i\)</span>是逐渐得到的，如果我们等到得到最后一个r的时候再去计算平均值就比较慢，因此，我们可以按照时序顺序来计算，用之前的平均值，加上当前的值与平均值的差距，再乘以一个小因子，相当于每次都给之前的平均值做一个调整。</p>
<h4 id="公式">1.2 公式</h4>
<p><span class="math display">\[
V(s_t)\leftarrow V(s_t)+\alpha[r_t+\gamma V(s_{t+1}-V(s_t)]
\]</span></p>
<h3 id="sarsa算法">2. Sarsa算法</h3>
<p>策略评估已经可以通过时序差分算法实现了，类似的我们可以使用时序差分算法去估计动作价值函数Q:
<span class="math display">\[
Q(s_t,a_t)\leftarrow
Q(s_t,a_t)+\alpha[r_t+Q(s_{t+1},a_{t+1})-Q(s_t,a_t)]
\]</span> 如果一直进行完全贪婪选择的话，可能会导致某些状态动作<span
class="math inline">\((s,a)\)</span>永远没有在序列中出现，导致无法对其动作价值进行估计，因此我们采用<span
class="math inline">\(\epsilon\)</span>贪婪策略</p>
<h3 id="q-learning算法">3. Q-learning算法</h3>
<p>Q-learning基于<strong>Bellman方程</strong>进行更新。</p>
<p><span class="math display">\[
Q(s, a) \leftarrow Q(s, a) + \alpha \left( r + \gamma \cdot
\max_{a&#39;} Q(s&#39;, a&#39;) - Q(s, a) \right)
\]</span></p>
<ul>
<li><span class="math inline">\(\max_{a&#39;} Q(s&#39;,
a&#39;)\)</span>：在下一个状态 ( s' )
下，所有可能动作中Q值最大的动作对应的Q值。</li>
</ul>
<h2 id="dqn算法">DQN算法</h2>
<h3 id="dqn">DQN</h3>
<p>参考公式30，我们的目标是使<span
class="math inline">\(Q(s,a)\)</span>和TD的目标<span
class="math inline">\(r+\gamma max_{a&#39; \in
A}Q(s&#39;,a&#39;)\)</span>靠近，于是 <span class="math display">\[
w^*=arg min_{w}\frac{1}{2N}\sum^N_{i=1}\left[Q_w(s_i,a_i)-\left( r +
\gamma \cdot \max_{a&#39;} Q(s&#39;, a&#39;) - Q(s, a) \right)\right]
\]</span></p>
<h3 id="经验回放">经验回放</h3>
<p>当前状态和上一个状态紧密相关，如果直接使用连续的样本进行训练，数据之间会高度相关，无法满足神经网络训练所需的独立同分布假设，通过经验回放（在训练神经网络的时候不使用agent最近收集的数据，而是从buffer中随机采样若干数据进行训练）打破样本之间的相关性，减少对神经网络训练的负面影响。</p>
<h3 id="目标网络">目标网络</h3>
<p>将损失函数分为两个部分，一个后半部分每次都更新，一个固定住</p>
<h3 id="double-dqn">Double DQN</h3>
<p>传统的DQN容易造成过高的估计，于是改写为 <span class="math display">\[
r+\gamma Q_{w^-}\left(s&#39;,arg max_{a&#39;}Q_w(s&#39;,a&#39;)\right)
\]</span> 其中目标网络的参数记做<span
class="math inline">\(w^-\)</span>,训练网络的参数记做<span
class="math inline">\(w\)</span></p>
<h3 id="dueling-dqn">Dueling DQN</h3>
<p>在 Dueling DQN 中，Q 网络被建模为： <span class="math display">\[
Q_{\eta,\alpha,\beta}(s,a)=V_{\eta,\alpha}(s)+A_{\eta,\beta}(s,a)
\]</span> <img
src="/Users/sunyuanxu/Library/Application%20Support/typora-user-images/image-20240907180441685.png"
alt="image-20240907180441685" /></p>
<p>分别建模的好处：某些情境下智能体只会关注状态的价值，而并不关心不同动作导致的差异，此时将二者分开建模能够使智能体更好地处理与动作关联较小的状态。</p>
<p>对于这样的Q值的计算，同一个Q值可能对应不同的V，A，因此Dueling DQN
强制最优动作的优势函数的实际输出为 0： <span class="math display">\[
Q_{\eta,\alpha,\beta}(s,a)=V_{\eta,\alpha}(s)+A_{\eta,\beta}(s,a)-max_{a&#39;}A_{\eta,\beta}(s,a&#39;)
\]</span> 也可以使用平均代替最大化操作： <span class="math display">\[
Q_{\eta,\alpha,\beta}(s,a)=V_{\eta,\alpha}(s)+A_{\eta,\beta}(s,a)-\frac{1}{|A|}\sum_{a&#39;}A_{\eta,\beta}(s,a&#39;)
\]</span> 其中<span
class="math inline">\(｜A｜\)</span>表示动作空间中所有可能的动作数量。</p>
<h2 id="策略梯度算法">策略梯度算法</h2>
<p>基于策略的方法则是直接显式的学习一个目标策略</p>
<h3 id="策略梯度">策略梯度</h3>
<p>基于策略的方法首先需要将策略参数化。假设目标策略<span
class="math inline">\(\pi_{\theta}\)</span>是一个随机性策略，并且处处可微，将策略学习的目标函数定义为<span
class="math inline">\(J(\theta)=E_{s_0}[V^{\pi_{\theta}}(s_0)]\)</span>，对其求导，然后使用梯队上升方法来最大化这个目标函数。
<span class="math display">\[
\nabla_{\theta}
J(\theta)=E_{\pi_{\theta}}[Q^{\pi_{\theta}}(s,a)\nabla_{\theta}\ log\
\pi_{\theta}(a|s)]
\]</span>
直观的理解就是增大能够得到较高Q值的动作的概率，减少较低Q值的动作的概率</p>
<p>Reinforce算法：有限步数环境下采样轨迹计算相应的价值，利用蒙特卡洛采样
<span class="math display">\[
\nabla_{\theta}
J(\theta)=E_{\pi_{\theta}}\left[\sum^T_{t=0}\left(\sum^T_{t&#39;=t}\gamma^{t&#39;-t}r_{t&#39;}\right)\nabla_{\theta}\
log\ \pi_{\theta}(a|s)\right]
\]</span> 使用当前策略采样，计算当前轨迹每个时刻t往后的回报，记作<span
class="math inline">\(\psi_t\)</span>,然后梯度上升 <span
class="math display">\[
\theta \leftarrow \theta+\alpha\sum_{t}^T\psi_t\nabla_{\theta}\ log\
\pi_{\theta}(a|s)
\]</span></p>
<h2 id="actor-critic算法">Actor-Critic算法</h2>
<p>优化一个带参数的策略，并且额外学习价值函数，帮助策略函数更好的学习</p>
<ul>
<li><p>Actor学习策略 <span class="math display">\[
\theta \leftarrow \theta+\alpha\sum_{t}^T\psi_t\nabla_{\theta}\ log\
\pi_{\theta}(a|s)
\]</span> 其中<span class="math inline">\(\psi_t\)</span>有多种</p></li>
<li><p>Critic学习价值函数，类似DQN，定义损失函数如下 <span
class="math display">\[
L(w)=\frac{1}{2}(r+\gamma V_{w}(s_{t+1})-V_w(s_t))^2
\]</span></p></li>
</ul>
<p>​ 梯度</p>
<p>​<br />
<span class="math display">\[
\nabla_w L(w)=-(r+\gamma V_{w}(s_{t+1})-V_w(s_t))\nabla_w V_w(s_t)
\]</span></p>
<h2 id="trpo算法">TRPO算法</h2>
<p>策略优化算法通过直接优化策略来找到最优策略，通常使用梯度下降的方法，然而有时会导致策略更新过大，从而使得新策略的性能不稳定甚至变差。因此需要保证新策略不会偏离当前策略太远，进而使得每次更新后策略的性能稳定提升。</p>
<p>定义新旧策略的目标函数的差距： <span class="math display">\[
\begin{align}
J(\theta&#39;)-J(\theta)&amp;=E_{\pi_{\theta&#39;}}\left[\sum^{\infty}_{t=0}\gamma^t[r(s_t,s_t)+\gamma
V^{\pi_{\theta}}(s_{t+1})-V^{\pi_{\theta}}(s_{t})]\right]\\
&amp;:=E_{\pi_{\theta&#39;}}\left[\sum^{\infty}_{t=0}\gamma^t
A^{\pi_{\theta}}(s_t,a_t) \right]\\
&amp;=\frac{1}{1-\gamma}E_{s\sim v^{\pi_{\theta&#39;}}}E_{a\sim
\pi_{\theta&#39;}(·|s)}[A^{\pi_{\theta}}(s,a)]
\end{align}
\]</span> 利用<span
class="math inline">\(v^{\pi_{\theta}}(s)=(1-\gamma)\sum^{\infty}_{t=0}\gamma^tP^{\pi}_{t}(s)\)</span>因此，只要新的策略保证<span
class="math inline">\(E_{s\sim v^{\pi_{\theta&#39;}}}E_{a\sim
\pi_{\theta&#39;}}(·|s)[A^{\pi_{\theta}}(s,a)]\geq 0\)</span>即可。</p>
<p>假设：新旧策略非常接近，状态访问分布变化小。因此直接采用旧策略的状态分布，得到替代的优化目标
<span class="math display">\[
L_{\theta}(\theta&#39;)=J(\theta)+E_{s\sim v^{\pi_{\theta}}}E_{a\sim
\pi_{\theta}(·|s)}[\frac{\pi_{\theta&#39;}(a|s)}{\pi_{\theta}(a|s)}A^{\pi_{\theta}}(s,a)]
\]</span> 为了限制新旧策略，因此引入KL散度，整体的优化公式 <span
class="math display">\[
max_{\theta&#39;}L_{\theta}(\theta&#39;) s.t.E_{s\sim
v^{\pi_{\theta}}}\left[D_{KL}(\pi_{\theta},\pi_{\theta&#39;})\right]
\]</span></p>
<h3 id="近似求解">近似求解</h3>
<p>参考<a
href="https://hrl.boyuai.com/chapter/2/trpo%E7%AE%97%E6%B3%95">动手学强化学习</a></p>
<h2 id="ppo">PPO</h2>
<p>直接将KL散度放到目标函数中， <span class="math display">\[
arg\ max_{\theta&#39;}E_{s\sim v^{\pi_{\theta}}}E_{a\sim
\pi_{\theta}(·|s)}[\frac{\pi_{\theta&#39;}(a|s)}{\pi_{\theta}(a|s)}A^{\pi_{\theta}}(s,a)-\beta
D_{KL}(\pi_{\theta},\pi_{\theta&#39;})]
\]</span></p>
<h3 id="ppo惩罚">PPO惩罚</h3>
<p>令<span
class="math inline">\(d_k=D_{KL}^{v^{\pi_{\theta}}}(\pi_{\theta},\pi_{\theta&#39;})\)</span>,<span
class="math inline">\(\beta\)</span>的更新规则如下： <span
class="math display">\[
\beta_{k+1}=
\begin{cases}
\frac{\beta_k}{2},\ 如果\ d_k &lt; \frac{\delta}{1.5} \\
\beta_k*2,\ 如果\ d_k &gt; \delta*1.5 \\
\beta_k, 否则\\
\end{cases}
\]</span></p>
<h3 id="ppo截断">PPO截断</h3>
<p><span class="math display">\[
\arg\max_{\theta} \mathbb{E}_{s \sim \nu} \mathbb{E}_{a \sim
\pi_{\theta_k}(\cdot|s)} \left[ \min \left(
\frac{\pi_{\theta}(a|s)}{\pi_{\theta_k}(a|s)} A^{\pi_{\theta_k}}(s, a),
\text{clip} \left( \frac{\pi_{\theta}(a|s)}{\pi_{\theta_k}(a|s)}, 1 -
\epsilon, 1 + \epsilon \right) A^{\pi_{\theta_k}}(s, a) \right) \right]
\]</span></p>
<p>相当于限制住优势函数，如果<span
class="math inline">\(A^{\pi_{\theta_k}}(s,
a)&gt;0\)</span>，最大化这个式子会增加<span
class="math inline">\(\frac{\pi_{\theta}(a|s)}{\pi_{\theta_k}(a|s)}\)</span>，但是不会超过<span
class="math inline">\(1+\epsilon\)</span>，如果<span
class="math inline">\(A^{\pi_{\theta_k}}(s,
a)&lt;0\)</span>，最大化这个式子会减小<span
class="math inline">\(\frac{\pi_{\theta}(a|s)}{\pi_{\theta_k}(a|s)}\)</span>，但是不会超过<span
class="math inline">\(1-\epsilon\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title>Android介绍</title>
    <url>/2024/07/20/android/</url>
    <content><![CDATA[<p>此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。
<span id="more"></span> # Android</p>
<h2 id="创建-android-应用">创建 Android 应用</h2>
<h3 id="使用模版创建项目">使用模版创建项目</h3>
<ol type="1">
<li>打开 Android Studio后，我们将看到类似的界面 <img
src="/images/kotlin/image-5.png" alt="alt text" /></li>
<li>点击 New project 之后，出现类似的界面 <img
src="/images/kotlin/image-6.png" alt="alt text" /></li>
<li>我们选择 Empty Activity ，看到如下界面 <img
src="/images/kotlin/image-7.png" alt="alt text" />
<ul>
<li>Name 字段用于输入项目名称。本次课程，请输入“Greeting Card”。</li>
<li>保持 Package name
字段不变。该字段用于指定文件在文件结构中的组织方式。在本例中，软件包名称将会指定为
com.example.greetingcard。</li>
<li>保持 Save location
字段不变。该字段用于指定保存与项目相关的所有文件的位置。请记下这些文件在计算机上的保存位置，以便查找文件。</li>
<li>在 Language 字段中，系统已选择
Kotlin。“Language”字段用于指定在构建项目时所采用的编程语言。由于 Compose
仅与 Kotlin 兼容，因此无法更改此字段。 然后点击完成，等待一会</li>
</ul></li>
<li>然后点击右上角的 <img src="/images/kotlin/image-8.png"
alt="alt text" />，可同时查看代码和设计。这个时候将会有三个区域 <img
src="/images/kotlin/image-9.png" alt="alt text" />
<ul>
<li>最左边的区域用于显示项目的文件和文件夹</li>
<li>中间的区域是修改代码的地方</li>
<li>右边的区域是预览应用外观的地方 <img
src="/images/kotlin/image-10.png" alt="alt text" />
可能最开始看到这样的界面，点击 Build &amp;
Refresh。构建可能需要花一些时间，不过完成后，预览便会显示一个内容为
Hello Android! 的文本框。</li>
</ul></li>
</ol>
<h3 id="更新文本">更新文本</h3>
<p>打开 MainActivity.kt 文件的 Code
视图。此代码中有一些自动生成的函数，具体而言就是 onCreate() 和
setContent() 函数。 <img src="/images/kotlin/image-11.png"
alt="alt text" /> onCreate()
函数是此应用的入口点，并会调用其他函数来构建 UI。在 Kotlin
程序中，main() 函数是 Kotlin 编译器在代码中开始编译的特定位置；在
Android 应用中，则是由 onCreate() 函数来担任这个角色。</p>
<p>onCreate() 函数中的 setContent()
函数用于通过可组合函数定义布局。任何标有 <span class="citation"
data-cites="Composable">@Composable</span> 注解的函数都可通过
setContent() 函数或其他可组合函数进行调用。该注解可告知 Kotlin 编译器
Jetpack Compose 使用的这个函数会生成 UI。</p>
<p>接下来，查看 Greeting() 函数。Greeting()
函数是一种可组合函数；请留意它上方的 <span class="citation"
data-cites="Composable">@Composable</span>
注解。可组合函数会接受一些输入并生成屏幕上显示的内容。 <img
src="/images/kotlin/image-12.png" alt="alt text" />
虽然我们在前面已经学习了函数，但是可组合函数还有一些不同之处： - <span
class="citation" data-cites="Composable">@Composable</span>
函数名称采用首字母大写形式。 - 需在该函数前面添加 <span class="citation"
data-cites="Composable">@Composable</span> 注解。 - <span
class="citation" data-cites="Composable">@Composable</span>
函数无法返回任何内容。</p>
<p>大家可以尝试加入不同的文本，我就以下面的为例子 <img
src="/images/kotlin/image-13.png" alt="alt text" />
然后最右边的视框会更新文字。</p>
<p>GreetingPreview()
无需构建整个应用就能查看应用的外观。若要使其成为预览函数，需要添加 <span
class="citation" data-cites="Preview">@Preview</span> 注解。</p>
<p><span class="citation" data-cites="Preview">@Preview</span>
注解可以接收名为 showBackground 的参数。如果 showBackground 设置为
true，则会向应用预览添加背景。如果使用深色主题，就可以看到如下所示的区别了。</p>
<p>可以在 GreetingPreview() 更新名字，显示预览。</p>
<h3 id="更改背景颜色">更改背景颜色</h3>
<p>若要为自我介绍设置不同的背景颜色，需要使用 Surface
将文本包围起来。Surface
是一个容器，代表界面的某一部分，可以在其中更改外观（如背景颜色或边框）。
<img src="/images/kotlin/image-14.png" alt="alt text" />
如果有报错的话，悬停，然后 import 即可 <img
src="/images/kotlin/image-15.png" alt="alt text" />
然后我们把颜色参数传进去即可 <img src="/images/kotlin/image-16.png"
alt="alt text" /></p>
<h3 id="添加内边距">添加内边距</h3>
<p>Modifier 用于扩充或修饰可组合项。可以使用的其中一个 Modifier 是
padding
修饰符，它会在元素周围应用空格（在本例中，是在文本周围添加空格）。为此，请使用
Modifier.padding() 函数。 <img src="/images/kotlin/image-17.png"
alt="alt text" /></p>
<h3 id="在-android-模拟器上运行应用">在 Android 模拟器上运行应用</h3>
<p>我们将使用设备管理器来创建 Android 虚拟设备 (AVD)。AVD
是移动设备的软件版本（也称为模拟器），可在计算机上运行，以及模拟特定类型
Android 设备的配置。它可以是任何手机、平板电脑、电视、手表或 Android
Auto 设备。我们将使用 AVD 来运行 Greeting Card 应用。</p>
<h4 id="创建-avd">创建 AVD</h4>
<ol type="1">
<li><p>在 Android Studio 中，依次选择 Tools &gt; Device Manager。 <img
src="/images/kotlin/image-18.png" alt="alt text" /> 系统随即会打开
Device Manager
对话框。如果以前创建过虚拟设备，则此对话框中会列出该设备。 <img
src="/images/kotlin/image-19.png" alt="alt text" /></p></li>
<li><p>我们点击左上角的加号，然后点击 Create virtual device 系统会显示出
Virtual Device Configuration 对话框。 <img
src="/images/kotlin/image-20.png" alt="alt text" />
该对话框会显示一个预配置设备的列表（按类别整理），可以从中选择。对于每种设备，该表都提供了相应列来分别显示其屏幕尺寸（以英寸为单位）、屏幕分辨率（以像素为单位）和像素密度（每英寸像素数）。</p></li>
<li><p>选择 Phone 类别。</p></li>
<li><p>选择所需手机（例如 Pixel 8），然后点击 Next。
此步骤会打开另一个屏幕，供选择在虚拟设备上运行的 Android
版本。这可在不同版本的 Android 系统上测试应用。 <img
src="/images/kotlin/image-21.png" alt="alt text" /> 大家 download
即可，点击 Next，看到如下界面，可以在其中为设备选择其他配置详情。 <img
src="/images/kotlin/image-22.png" alt="alt text" /></p></li>
<li><p>在 AVD Name 字段中，输入 AVD
的名称，或使用默认名称。保持其余字段不变。</p></li>
<li><p>点击 Finish。 系统会返回到 Android Virtual Device Manager
窗格。</p></li>
</ol>
<h4 id="在-android-模拟器上运行应用-1">在 Android 模拟器上运行应用</h4>
<ol type="1">
<li>在 Android Studio 窗口顶部选择创建的虚拟设备。 <img
src="/images/kotlin/image-23.png" alt="alt text" /></li>
<li>点击旁边的绿色三角 <img src="/images/kotlin/image-24.png"
alt="alt text" /></li>
<li>模拟器首次启动需要一些时间，有可能是几分钟。虚拟设备应该会在代码编辑器旁边打开。
<img src="/images/kotlin/image-25.png" alt="alt text" />
当应用准备就绪后，便会在虚拟设备上打开。 <img
src="/images/kotlin/image-26.png" alt="alt text" /></li>
</ol>
<h2 id="构建基本布局">构建基本布局</h2>
<p>构建一个显示文本和图像的、界面简单的 Android 应用。</p>
<h3 id="jetpack-compose-介绍">Jetpack Compose 介绍</h3>
<p>下面我们来介绍刚刚前面提到的 compose。</p>
<p>首先，Jetpack Compose 是用于构建 Android 界面的新款工具包。Compose
使用更少的代码、强大的工具和直观的 Kotlin 功能，可以帮助简化并加快
Android 界面开发。借助
Compose，可以通过定义一组函数来构建界面，这些函数称为可组合函数，它们会接受数据并描述界面元素。</p>
<h4 id="可组合函数">可组合函数</h4>
<p>在 Compose 中，可组合函数是界面的基本构建块。可组合函数： -
描述界面中的某一部分。 - 不会返回任何内容。 -
接受一些输入并生成屏幕上显示的内容。</p>
<h4 id="注解">注解</h4>
<p>注解是用于在代码中附加额外信息的方式。此类信息可以帮助 Jetpack
Compose 编译器等工具和其他开发者理解应用的代码。</p>
<p>若要应用注解，只需在要注解的声明开头为其名称（注解）添加 @
字符作为前缀即可。可以为包括属性、函数和类在内的不同代码元素添加注解。
<img src="/images/kotlin/image-27.png" alt="alt text" /></p>
<h5 id="带形参的注解">带形参的注解</h5>
<p>注解可以接受形参。形参可以为处理它们的工具提供额外信息。就像我们之前用到的
<span class="citation" data-cites="Preview">@Preview</span>
注解，可以加入不同的形参。 <img src="/images/kotlin/image-29.png"
alt="alt text" /> <img src="/images/kotlin/image-30.png"
alt="alt text" /> <img src="/images/kotlin/image-31.png"
alt="alt text" /></p>
<p>当然，也可以传递多个参数 <img src="/images/kotlin/image-32.png"
alt="alt text" /></p>
<h4 id="可组合函数示例">可组合函数示例</h4>
<p>可组合函数带有 <code>@Composable</code>
注解。所有可组合函数都必须带有此注解。此注解可告知 Compose
编译器：此函数用于将数据转换为界面。</p>
<p>以下代码段是一个简单的可组合函数示例，该函数接受传递的数据（<code>name</code>
函数参数）并用其在屏幕上渲染文本元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Text(text = <span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于可组合函数的几点说明： - Jetpack Compose
是围绕可组合函数构建的。这些函数可让以程序化方式定义应用的界面，只需描述应用界面的外观，而不必关注界面的构建过程。如需创建可组合函数，只需将
<code>@Composable</code> 注解添加到函数名称中即可。 -
可组合函数可以接受一些实参，用来让应用逻辑描述或修改界面。在本例中，界面元素接受一个
<code>String</code>，以便在问候用户时称呼姓名。</p>
<h4 id="可组合函数名称">可组合函数名称</h4>
<p>不返回任何内容且带有 <code>@Composable</code> 注解的 Compose
函数必须使用 Pascal 命名法命名。Pascal
命名法是一种命名惯例，采用这种命名法时，复合词中每个单词的首字母大写。Pascal
命名法与骆驼命名法之间的区别在于：在 Pascal
命名法中，所有单词的首字母都大写；而在骆驼命名法中，首字母可以是大写或小写。</p>
<p>Compose 函数：</p>
<ul>
<li>必须是名词：<code>DoneButton()</code></li>
<li>不能是动词或动词短语：<code>DrawTextField()</code></li>
<li>不能是名词性介词：<code>TextFieldWithLink()</code></li>
<li>不能是形容词：<code>Bright()</code></li>
<li>不能是副词：<code>Outside()</code></li>
<li>名词可以添加描述性形容词作为前缀：<code>RoundIcon()</code></li>
</ul>
<h3 id="添加新的文本元素">添加新的文本元素</h3>
<ol type="1">
<li>删除 <code>Greeting</code> 函数以及调用，并将
<code>GreetingPreview</code> 替换为
<code>HappyBirthdayPreview</code>。</li>
<li>在 <code>BirthdayCardPreview()</code> 函数前，添加一个名为
<code>GreetingText()</code> 的新函数。不要忘记在该函数前添加
<code>@Composable</code> 注解，因为该函数是一个用于描述
<code>Text</code> 可组合项的 Compose 函数。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>最好让可组合项接受 <code>Modifier</code> 形参，并将该
<code>modifier</code> 传递给其第一个子项。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>将类型为 <code>String</code> 的 <code>message</code> 形参添加到
<code>GreetingText()</code> 可组合函数中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>在 <code>GreetingText()</code> 函数中，添加一个 <code>Text</code>
可组合项并传入文本消息作为具体实参。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = message</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此 <code>GreetingText()</code>
函数用于在界面中显示文本。为此，它会调用 <code>Text()</code>
可组合函数。</p>
<ol start="6" type="1">
<li><p>预览函数 在 <code>BirthdayCardPreview()</code> 函数中调用
<code>GreetingText()</code> 函数。 将一个 <code>String</code> 参数传递给
<code>GreetingText()</code> 函数。</p></li>
<li><p>更改字体大小 可以到 <code>GreetingText()</code> 函数中的
<code>Text()</code> 可组合项。向 <code>Text()</code> 函数传递
<code>fontSize</code> 实参作为第二个具名实参，并将其值设为
<code>100.sp</code>。</p></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = message,</span><br><span class="line">        fontSize = <span class="number">100.</span>sp</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image-33.png" alt="alt text" /> 8.
消息重叠的原因是需要指定行高。更新 <code>Text</code>
可组合项以包含行高。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = message,</span><br><span class="line">        fontSize = <span class="number">100.</span>sp,</span><br><span class="line">        lineHeight = <span class="number">110.</span>sp,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image-34.png" alt="alt text" /> 9.
添加一个新的文本元素 在 <code>GreetingText()</code>
函数，向该函数传递一个类型为 <code>String</code> 的 <code>from</code>
参数作为的签名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, from: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span></span><br></pre></td></tr></table></figure>
<p>在生日祝福语 <code>Text</code> 可组合项之后，再添加一个接受
<code>text</code> 实参（其值设为 <code>from</code>）的 <code>Text</code>
可组合项。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, from: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )</span><br><span class="line">    Text(</span><br><span class="line">        text = from</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一个 <code>fontSize</code> 具名实参，并将其值设为
<code>36.sp</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = from,</span><br><span class="line">    fontSize = <span class="number">36.</span>sp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 <code>BirthdayCardPreview()</code> 函数再添加一个
<code>String</code> 实参来为生日卡签名。 <img
src="/images/kotlin/image-35.png" alt="alt text" />
一个可组合函数可能会描述多个界面元素。不过，如果未提供有关如何排列这些元素的指导，Compose
可能会以不喜欢的方式排列它们。例如，上面的代码生成了两个相互重叠的文本元素，因为没有提供有关如何排列这两个可组合项的指导。</p>
<h3 id="将文本元素排列成一行或一列">将文本元素排列成一行或一列</h3>
<h4 id="界面层次结构">界面层次结构</h4>
<p>界面层次结构基于包含机制，意即一个组件可以包含一个或多个组件，有时会用“父级”和“子级”这两个词来表述。这种说法是指，父界面元素包含子界面元素，而子界面元素还可以继续包含子界面元素。在此部分中，将了解可用作父界面元素的
<code>Column</code>、<code>Row</code> 和 <code>Box</code> 可组合项。</p>
<p>Compose 中的 3 个基本标准布局元素是
<code>Column</code>、<code>Row</code> 和 <code>Box</code> 可组合项。</p>
<p><code>Column</code>、<code>Row</code> 和 <code>Box</code>
都是接受可组合内容作为参数的可组合函数，因此可以在这些布局元素内放置项目。例如，<code>Row</code>
可组合项中的各个子元素彼此相邻地水平放置成一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t copy.</span></span><br><span class="line">Row &#123;</span><br><span class="line">    Text(<span class="string">&quot;First Column&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;Second Column&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/kotlin/image-36.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>因此，在我们的函数中可以使用 <code>Row</code>
对文字进行布局（暂时将生日祝福语的字体大小更改为
<code>30.sp</code>）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, from: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Row &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = message,</span><br><span class="line">            fontSize = <span class="number">30.</span>sp,</span><br><span class="line">            lineHeight = <span class="number">110.</span>sp,</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            text = from,</span><br><span class="line">            fontSize = <span class="number">36.</span>sp</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image-37.png" alt="alt text" />
我们也可以使用 <code>Column</code> 来将文本元素排成一列。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, from: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = message,</span><br><span class="line">            fontSize = <span class="number">100.</span>sp,</span><br><span class="line">            lineHeight = <span class="number">110.</span>sp,</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            text = from,</span><br><span class="line">            fontSize = <span class="number">36.</span>sp</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/kotlin/image-38.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<h3 id="在模拟器上运行">在模拟器上运行</h3>
<p>我们可以回到 <code>onCreate()</code> 函数，从 <code>Scaffold</code>
代码块调用 <code>GreetingText()</code> 函数，传递
<code>GreetingText()</code> 函数、的生日祝福和签名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        enableEdgeToEdge()</span><br><span class="line">        setContent &#123;</span><br><span class="line">            HappyBirthdayTheme &#123;</span><br><span class="line">                Scaffold(modifier = Modifier.fillMaxSize()) &#123; innerPadding -&gt;</span><br><span class="line">                    GreetingText(</span><br><span class="line">                        message = <span class="string">&quot;Happy Birthday Sam!&quot;</span>,</span><br><span class="line">                        from = <span class="string">&quot;From Emma&quot;</span>,</span><br><span class="line">                        modifier = Modifier.padding(innerPadding))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image-39.png" alt="alt text" />
如需在屏幕中心对齐问候语，请添加一个名为
<code>verticalArrangement</code> 的形参，并将其设置为
<code>Arrangement.Center</code>。围绕列添加 <code>8.dp</code>
内边距。最好以 <code>4.dp</code> 为增量使用内边距值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingText</span><span class="params">(message: <span class="type">String</span>, from: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        verticalArrangement = Arrangement.Center,</span><br><span class="line">        modifier = modifier.padding(<span class="number">8.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>textAlign</code> 将问候语文本居中对齐。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = message,</span><br><span class="line">    fontSize = <span class="number">100.</span>sp,</span><br><span class="line">    lineHeight = <span class="number">116.</span>sp,</span><br><span class="line">    textAlign = TextAlign.Center</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为签名添加内边距，并使其右对齐。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = from,</span><br><span class="line">    fontSize = <span class="number">36.</span>sp,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .padding(<span class="number">16.</span>dp)</span><br><span class="line">        .align(alignment = Alignment.End)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/kotlin/image-40.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
]]></content>
  </entry>
  <entry>
    <title>Android Studio介绍</title>
    <url>/2024/07/29/android_studio/</url>
    <content><![CDATA[<p>此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。
<span id="more"></span> ## Android Studio环境搭建</p>
<h3 id="指南">指南</h3>
<p>我们为各位同学提供谷歌的<a
href="https://developer.android.com/studio?hl=zh-cn">官方教程</a>进行参考，请按教程PDF中的第1.1节进行Android
Studio的配置。</p>
<p>此外，使用windows系统建议在C:.gradle.gradle文件（<a
href="https://cloud.tsinghua.edu.cn/f/ae3cb15f675946dbba9e/?dl=1">点击下载</a>），这样可以使用阿里云镜像提高gradle下载的速度，Mac版参考链接<a
href="https://blog.csdn.net/mickjoust/article/details/100917237">点击这里</a>。</p>
<h3 id="安装android-studio">2.1 安装Android Studio</h3>
<p>官方下载安装地址: <a
href="https://developer.android.com/studio?hl=zh-cn">https://developer.android.com/studio?hl=zh-cn</a></p>
<p>在用Android
Studio创建项目后可能遇到<code>gradle sync failed</code>错误，这是由于国内网络无法直连github.com。</p>
<h4 id="gradle换源">2.1.1 Gradle换源</h4>
<p>解决这个问题的方法之一是更换gradle的下载地址：</p>
<ol type="1">
<li>在用户目录<code>/.gradle/</code>文件夹下创建一个<code>init.gradle</code>文件</li>
<li>在<code>init.gradle</code>文件中输入以下内容</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span></span><br><span class="line">        all &#123;</span><br><span class="line">            ArtifactRepository repo -&gt;</span><br><span class="line">                <span class="keyword">if</span> (repo <span class="keyword">instanceof</span> MavenArtifactRepository) &#123;</span><br><span class="line">                    <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                        project.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://jcenter.bintray.com/&#x27;</span>)) &#123;</span><br><span class="line">                        project.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maven &#123;</span><br><span class="line">        allowInsecureProtocol = <span class="literal">true</span></span><br><span class="line">        url ALIYUN_REPOSITORY_URL</span><br><span class="line">        url ALIYUN_JCENTER_URL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完后点击重新同步，Android Studio便可以正常下载相关文件。</p>
<h3 id="android-studio配置代理">2.1.2 Android Studio配置代理</h3>
<p>解决这个问题的方法之一是为Android Studio配置代理：</p>
<ol type="1">
<li>选择 <code>file-&gt;settings</code></li>
<li>选择找到 <code>HTTP Proxy</code></li>
</ol>
<figure>
<img src="/images/kotlin/image-41.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>配置完代理后点击重新同步，Android Studio便可以正常下载相关文件。</p>
<h3 id="直接下载gradle依赖包">2.1.3 直接下载Gradle依赖包</h3>
<p>可以参考这个教程： <a
href="https://blog.csdn.net/qq_42257666/article/details/129651505">https://blog.csdn.net/qq_42257666/article/details/129651505</a></p>
]]></content>
  </entry>
  <entry>
    <title>常见命令</title>
    <url>/2024/10/03/command/</url>
    <content><![CDATA[<p>记录了常见的一些命令，包括docker,git,ssh,proxy,scp等。</p>
<h1 id="docker">docker</h1>
<h2 id="基础命令">基础命令</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;container_id_or_name&gt;</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="git">git</h1>
<h2 id="基础命令-1">基础命令</h2>
<h3 id="init">Init</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin url</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git checkout -b new-branch</span><br><span class="line">git push -u origin new-branch</span><br></pre></td></tr></table></figure>
<h3 id="branch">Branch</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -r(remote)</span><br></pre></td></tr></table></figure>
<h3 id="checkout">Checkout</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branch_name</span><br><span class="line">git checkout -b local_branch_name origin/remote_branch_name</span><br></pre></td></tr></table></figure>
<h3 id="lfs">LFS</h3>
<p>处理文件过大问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git lfs track &quot;file&quot;</span><br></pre></td></tr></table></figure> # ssh ## 常见命令</p>
<p>这个命令通过 <code>ssh</code>
进行远程连接，并设置了一个反向代理通道。详细解释如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -R 7890:localhost:7890 username@ip -p port -A -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<h3 id="命令结构">1. 命令结构</h3>
<p><code>ssh</code> 是用于通过 SSH（Secure
Shell）协议进行远程连接的命令。这个命令的各个选项含义如下：</p>
<h4 id="r-7890localhost7890"><code>-R 7890:localhost:7890</code></h4>
<ul>
<li><strong>反向端口转发</strong>：<code>-R</code>
选项用于创建一个反向端口转发。
<ul>
<li><code>7890</code>（左边的部分）：这是远程主机（<code>username@ip</code>
这台主机）上的端口号。</li>
<li><code>localhost</code>：这是指向 SSH
客户端机器的主机名，即本地主机（你正在运行这个命令的机器）。</li>
<li><code>7890</code>（右边的部分）：这是本地机器上开放的端口号。</li>
</ul>
<strong>功能</strong>：
<ul>
<li>当你连接到远程主机 <code>username@ip</code> 后，远程主机上的
<code>7890</code> 端口就会被绑定到你的本地机器的 <code>7890</code>
端口。</li>
<li>任何连接到远程主机的 <code>7890</code> 端口的数据流都会通过 SSH
隧道安全地传递到本地主机的 <code>7890</code>
端口。这通常用于在远程主机上通过本地资源进行网络请求。</li>
</ul></li>
</ul>
<h4 id="usernameip"><code>username@ip</code></h4>
<ul>
<li><strong>用户名和 IP 地址</strong>：
<ul>
<li><code>username</code>：远程主机上的用户名，表示你要用哪个用户身份登录到远程服务器。</li>
<li><code>ip</code>：远程主机的 IP
地址或域名。你通过该地址来连接到远程服务器。</li>
</ul></li>
</ul>
<h4 id="p-port"><code>-p port</code></h4>
<ul>
<li><strong>指定端口</strong>：
<ul>
<li><code>-p</code> 用于指定远程主机上的 SSH 服务端口号。默认情况下，SSH
服务器使用端口 <code>22</code>，但有时会改为其他端口以提高安全性。</li>
</ul></li>
</ul>
<h4 id="a"><code>-A</code></h4>
<ul>
<li><strong>代理转发</strong>：
<ul>
<li><code>-A</code> 选项表示启用 SSH 代理转发（agent
forwarding）。代理转发使得你可以在登录远程主机后，通过该远程主机来访问其他服务器而不需要再次输入密码。</li>
<li>这样，当你通过该远程主机再连接其他服务器时，会自动使用你本地的 SSH
密钥，简化连接过程。</li>
</ul></li>
</ul>
<h4 id="i-.sshid_rsa"><code>-i ~/.ssh/id_rsa</code></h4>
<ul>
<li><strong>指定私钥文件</strong>：
<ul>
<li><code>-i</code> 用于指定一个 SSH 私钥文件路径。</li>
<li><code>~/.ssh/id_rsa</code>
是存储在你本地的私钥文件，用于身份验证。如果你使用其他名字的私钥文件，你需要修改这里的路径。</li>
</ul></li>
</ul>
<h1 id="安装flash-attn">安装flash-attn</h1>
<p>Install the pre-build wheel list in release page works for me, in my
case: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install https://github.com/Dao-AILab/flash-attention/releases/download/v2.3.3/flash_attn-2.3.3+cu118torch2.0cxx11abiFALSE-cp38-cp38-linux_x86_64.whl</span><br></pre></td></tr></table></figure></p>
<h1 id="mac终端代理">Mac终端代理</h1>
<ol type="1">
<li>修改<code>!/.zshrc</code>,加入下面的命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># where proxy</span></span><br><span class="line"> <span class="function"><span class="title">proxy</span></span> () &#123;</span><br><span class="line"> <span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"> <span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;HTTP Proxy on&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment"># where noproxy</span></span><br><span class="line"> <span class="function"><span class="title">noproxy</span></span> () &#123;</span><br><span class="line"> <span class="built_in">unset</span> http_proxy</span><br><span class="line"> <span class="built_in">unset</span> https_proxy</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;HTTP Proxy off&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>source ~/.zshrc</code></li>
<li><code>proxy</code>(you will see "HTTP Proxy on")</li>
<li><code>curl ipinfo.io</code>（查看当前的IP）</li>
</ol>
<h1 id="scp">scp</h1>
<h2 id="两个服务器之间传输">两个服务器之间传输</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -3 sun:/raid/sunyuanxu/jsonl_sum/sum.jsonl code:/share/sunyuanxu/maxcoverage（配合~/.ssh/config使用）</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>sftp</title>
    <url>/2024/10/03/sftp/</url>
    <content><![CDATA[<p>vscode的一个插件，每次我的代码有更新的时候，就需要重写scp，但是使用这个插件之后就不需要我自己手动的去scp了，每当我修改的时候就自动上传过去。
<span id="more"></span> ## 配置方法 1. 打开vscode，使用<code>shift+command+p</code>
2. <code>SFTP:Config</code> 3. 按照类似的方式配置 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tj&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server_ip&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sftp&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">2201</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;username&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;remotePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;uploadOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;useTempFile&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;openSsh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;interactiveAuth&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;privateKeyPath&quot;</span><span class="punctuation">:</span><span class="string">&quot;~/.ssh/id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;passphrase&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>Kotlin 介绍</title>
    <url>/2024/07/18/kotlin/</url>
    <content><![CDATA[<p>此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。
<span id="more"></span> ## Kotlin 介绍</p>
<p>Kotlin 是一种现代且成熟的编程语言，由 JetBrains 公司于 2011
年设计和开发，并在 2016 年正式发布。在 2019 年的 Google I/O
大会上，Google 宣布 Kotlin 将成为 Android 开发的首选语言。包括 Google
地图、Google Home、Play、Google 云端硬盘和 Google
信息等应用。其中一个成功案例来自 Google Home
团队，他们将新功能开发工作迁移到 Kotlin 后，代码库大小减少了 33%，NPE
崩溃次数减少了 30%。Kotlin
以其简洁性和强大的功能而闻名，不仅能减少常见的代码错误，还能轻松集成到现有的应用程序中。如果打算构建
Android 应用，建议从 Kotlin 开始，充分利用其一流的功能。</p>
<p>开发者倾向于使用 Kotlin 的原因主要有以下几个：</p>
<ul>
<li><strong>富有表现力且简洁</strong>：使用更少的代码实现更多的功能，减少样板代码，表达更加清晰。</li>
<li><strong>更安全的代码</strong>：Kotlin
提供许多语言特性，帮助避免空指针异常等常见的编程错误。</li>
<li><strong>高度互操作</strong>：Kotlin 与 Java 完全互操作，可以在
Kotlin 代码中调用 Java 代码，或在 Java 代码中调用 Kotlin
代码，让可以在项目中无缝添加 Kotlin 代码。</li>
</ul>
<h2 id="kotlin-语言基础">Kotlin 语言基础</h2>
<p>此教程主要用于Kotlin速成，快速上手。 <a
href="https://play.kotlinlang.org/">在线kotlin</a>编辑器 ###
变量声明</p>
<p>在 Kotlin 中，变量的声明采用两种不同的关键字：<code>val</code> 和
<code>var</code>。</p>
<ul>
<li><code>val</code>
用于声明不可变的变量，即一旦赋值后就不能再更改。</li>
<li><code>var</code> 用于声明可变的变量，即可以多次赋值。</li>
</ul>
<p>例如，<code>count</code> 是一个 <code>Int</code> 类型的变量，初始值为
<code>10</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image.png" alt="alt text" />
<code>Int</code> 是表示整数的类型之一。Kotlin 还提供了其他数值类型，如
<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Float</code>
和
<code>Double</code>，以满足不同的数值需求。以下是这些类型的简要说明：</p>
<p>在 Kotlin
中，有一些常见的基本数据类型。下表逐行列明了各种不同的数据类型，并针对每种数据类型提供了可存储数据类型的说明和示例值。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Kotlin 数据类型</th>
<th>可包含的数据类型</th>
<th>字面量值示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>文本</td>
<td>"Add contact"<br>"Search"<br>"Sign in"</td>
</tr>
<tr>
<td>Int</td>
<td>整数</td>
<td>32<br>1293490<br>-59281</td>
</tr>
<tr>
<td>Double</td>
<td>小数</td>
<td>2.0<br>501.0292<br>-31723.99999</td>
</tr>
<tr>
<td>Float</td>
<td>小数 (不如 Double 精确)，数字末尾带有 <code>f</code> 或
<code>F</code></td>
<td>5.0f<br>-1630.209f<br>1.2940278F</td>
</tr>
<tr>
<td>Boolean</td>
<td><code>true</code> 或 <code>false</code>。当只有两个可能的值时,
可使用此数据类型。请注意，<code>true</code> 和 <code>false</code> 是
Kotlin 中的关键字。</td>
<td><code>true</code><br><code>false</code></td>
</tr>
</tbody>
</table>
<p>使用 <code>var</code> 关键字意味着可以重新赋值给
<code>count</code>。例如，可以将 <code>count</code> 的值从
<code>10</code> 改为 <code>15</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">count = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>有些变量的值是不应该更改的。假设有一个名为 <code>languageName</code>
的 <code>String</code> 类型变量，如果希望确保 <code>languageName</code>
的值始终为 “Kotlin”，可以使用 <code>val</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName: String = <span class="string">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>val</code> 和
<code>var</code>，可以明确区分哪些变量的值是可变的，哪些是不可变的。针对不同的需求做出适当的选择。如果变量的值需要改变，则使用
<code>var</code>；否则，使用 <code>val</code>。 #### 编码规范
一些格式设置和编码规范：</p>
<ul>
<li>变量名称应采用驼峰式大小写形式，并以小写字母开头。</li>
<li>在变量声明中指定数据类型时，应在冒号后面添加一个空格。</li>
<li>赋值运算符（=）、加号（+）、减号（-）、乘号（*）、除号（/）等运算符的前后应有空格。</li>
</ul>
<h4 id="注释">注释</h4>
<p>编写代码时，另一个建议遵循的较好做法是添加注释来说明代码的用途。这样做可帮助读者更轻松地理解代码。可以使用两个正斜杠符号
(<code>//</code>)
来指明将相应行中该符号后的剩余文本视为注释，而不要解释为代码。通常的做法是在两个正斜杠符号后添加一个空格。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a comment.</span></span><br></pre></td></tr></table></figure>
<p>也可以在一行代码的中间位置插入注释。在下面的示例中，<code>height = 1</code>
是正常的编码语句。<code>//</code> 之后的所有内容（即
<code>Assume the height is 1 to start with</code>）都会被解释为注释，而不会被视为代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">height = <span class="number">1</span> <span class="comment">// Assume the height is 1 to start with.</span></span><br></pre></td></tr></table></figure>
<p>对于多行注释而言。具体方法为：使用由正斜杠 (<code>/</code>) 和星号
(<code>*</code>) 组成的 <code>/*</code>
来作为多行注释的开头，在注释的每个新行开头添加一个星号，最后使用由星号和正斜杠符号组成的
<code>*/</code> 作为结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a very long comment that can</span></span><br><span class="line"><span class="comment">* take up multiple lines.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="类型推断">类型推断</h4>
<p>Kotlin
拥有强大的类型推断功能，可以根据初始值自动推断变量的类型，从而简化代码。延续前面的示例，在为
<code>languageName</code> 赋值后，Kotlin
编译器会根据初始值推断其类型。</p>
<p>由于 <code>"Kotlin"</code> 是 <code>String</code>
类型，因此编译器推断 <code>languageName</code> 也为
<code>String</code>。 &gt; 注意：Kotlin
是一种静态类型语言，这意味着类型在编译时解析并且不会改变。</p>
<p>在以下示例中，<code>languageName</code> 被推断为
<code>String</code>，因此只能调用 <code>String</code> 类的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">val</span> upperCaseName = languageName.uppercase() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line">languageName.inc()</span><br></pre></td></tr></table></figure>
<p><code>uppercase()</code>
是一个用于将字符串中的小写字母转换为大写字母的 <code>String</code>
类型方法。由于 Kotlin 编译器已将 <code>languageName</code> 推断为
<code>String</code>，因此可以成功调用
<code>uppercase()</code>。然而，<code>inc()</code> 是一个
<code>Int</code> 类型的方法，用于将数值增加 1，因此不能对
<code>String</code> 类型调用它。通过 Kotlin
的类型推断，可以使代码更加简洁且类型安全。</p>
<h3 id="条件语句">条件语句</h3>
<p>Kotlin 提供了几种实现条件逻辑的机制，其中最常见的是
<code>if-else</code>
语句。这种语句用于基于条件的真伪来执行不同的代码块。语法非常直观：如果
<code>if</code> 关键字后面的表达式求值为
<code>true</code>，则执行该分支中的代码；否则，执行 <code>else</code>
分支中的代码。让我们看一个简单的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer eludes me.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>else if</code>
表示多个条件。这样，就可以在单个条件语句中表示更精细、更复杂的逻辑。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">35</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer is close.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer eludes me.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件语句对于表示有状态的逻辑非常有用，但可能会发现，编写这些语句时会出现重复。在上面的示例中，每个分支都是输出一个
<code>String</code>。为了避免这种重复，Kotlin
提供了条件表达式。最后一个示例可以重新编写如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString: String = <span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">    <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">35</span>) &#123;</span><br><span class="line">    <span class="string">&quot;The answer is close.&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(answerString)</span><br></pre></td></tr></table></figure>
<p>每个条件分支都隐式地返回其最后一行的表达式的结果，因此无需使用
<code>return</code> 关键字。由于全部三个分支的结果都是
<code>String</code> 类型，因此 <code>if-else</code> 表达式的结果也是
<code>String</code> 类型。在本例中，根据 <code>if-else</code>
表达式的结果为 <code>answerString</code>
赋予了一个初始值。利用类型推断可以省略 <code>answerString</code>
的显式类型声明，但为了清楚起见，通常最好添加该声明。</p>
<blockquote>
<p>注意：Kotlin 不包含传统的三元运算符
(<code>?:</code>)，而是倾向于使用条件表达式。这使得代码更加简洁明了。</p>
</blockquote>
<p>随着条件语句的复杂性不断增加，可以考虑将 <code>if-else</code>
表达式替换为 <code>when</code> 表达式，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = <span class="keyword">when</span> &#123;</span><br><span class="line">    count == <span class="number">42</span> -&gt; <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    count &gt; <span class="number">35</span> -&gt; <span class="string">&quot;The answer is close.&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(answerString)</span><br></pre></td></tr></table></figure>
<p><code>when</code> 表达式中每个分支都由一个条件、一个箭头
(<code>-&gt;</code>) 和一个结果来表示。如果分支头左侧的条件求值为
<code>true</code>，则返回右侧的表达式结果。请注意，执行并不是从一个分支跳转到下一个分支。<code>when</code>
表达式示例中的代码在功能上与上一个示例中的代码等效，但结构更为清晰。</p>
<p>此外，<code>when</code>
表达式不仅可以用于简单的条件判断，还可以用于更复杂的模式匹配。例如，可以根据变量的类型执行不同的操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkType</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">&quot;This is a String of length <span class="subst">$&#123;obj.length&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;This is an Integer with value <span class="variable">$obj</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构">循环结构</h3>
<p>Kotlin 提供了几种实现循环的机制，其中最常见的是 <code>for</code>
循环和 <code>while</code> 循环。</p>
<h4 id="for-循环"><code>for</code> 循环</h4>
<p><code>for</code>
循环用于遍历集合、数组或区间，并对每个元素执行指定的操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>numbers</code>
是一个包含整数的列表。<code>for</code>
循环将依次遍历列表中的每个元素，并将当前元素赋值给 <code>number</code>
变量，然后执行循环体中的代码块。</p>
<p>可以使用 <code>for</code> 循环遍历任何实现了 <code>Iterable</code>
接口的对象，例如集合、数组或区间。以下是一些使用 <code>for</code>
循环的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历区间</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个示例中，<code>for</code> 循环遍历数组 <code>array</code>
中的每个元素，并将当前元素赋值给 <code>element</code>
变量。第二个示例展示了如何遍历一个从 1 到 5 的区间。</p>
<p>有时，不仅需要访问元素的值，还需要访问元素的索引。这时可以使用
<code>withIndex</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;Element at <span class="variable">$index</span> is <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>withIndex</code> 函数返回一个包含索引和值的
<code>IndexedValue</code> 对象。通过解构声明，可以将索引和值分别赋值给
<code>index</code> 和 <code>value</code> 变量。</p>
<p>Kotlin 还提供了一种更简洁的方式来遍历区间：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>1 until 5</code> 表示从 1 到 4 的半开区间，不包括
5。在循环中，<code>i</code> 的值依次为 1, 2, 3, 4。</p>
<p>如果需要以特定步长遍历区间，可以使用 <code>step</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>1..10 step 2</code> 表示从 1 到 10
的区间，步长为 2。循环体中的 <code>i</code> 将依次取值 1, 3, 5, 7,
9。</p>
<p>此外，还可以使用 <code>downTo</code> 函数以递减顺序遍历区间：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>10 downTo 1</code> 表示从 10 到 1
的递减区间。<code>for</code>
循环可以高效地遍历任何类型的集合，并且可以与其他 Kotlin
特性（如解构声明和类型推断）结合使用，以进一步简化代码。</p>
<h4 id="while-循环"><code>while</code> 循环</h4>
<p><code>while</code>
循环用于在给定条件为真时重复执行一段代码。<code>while</code>
循环在每次迭代前都会检查条件，如果条件为真，则执行循环体中的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;Count is <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">    count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>count</code> 变量初始值为 0。<code>while</code>
循环在每次迭代前检查 <code>count &lt; 5</code>
是否为真。如果为真，则执行循环体中的代码，输出当前 <code>count</code>
的值，并将 <code>count</code> 增加 1。循环将一直执行，直到
<code>count</code> 的值不再小于 5。</p>
<p><code>do-while</code> 循环与 <code>while</code>
循环类似，但它会先执行一次循环体中的代码，然后再检查条件。这意味着
<code>do-while</code> 循环至少会执行一次。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Count is <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">    count++</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，即使初始条件为假，<code>do-while</code>
循环也会执行一次循环体中的代码，然后再检查 <code>count &lt; 5</code>
是否为真。</p>
<p>通过合理使用 <code>for</code> 循环和 <code>while</code>
循环，可以简洁、高效地遍历各种集合、数组和区间，并对每个元素执行所需的操作。这些循环结构在编写高效、可维护的代码时非常有用，特别是在处理大量数据或需要重复执行某些操作时。</p>
<h3 id="函数">函数</h3>
<p>可以将相应的表达式封装在一个函数中并调用该函数，而不必在每次需要某个结果时都重复同一系列的表达式。</p>
<p>要声明函数，请使用 <code>fun</code>
关键字，后跟函数名称。定义函数时，可以指定希望其返回的值的数据类型。如果指定返回值类型，只需在圆括号后面添加冒号
(<code>:</code>)，然后在冒号后面添加一个空格和类型名称（例如
<code>Int</code>、<code>String</code>
等）。然后，在返回值类型与左大括号之间添加一个空格。在函数主体中，可以在所有语句之后使用
<code>return</code> 语句指定希望函数返回的值。<code>return</code>
语句包含 <code>return</code>
关键字，后跟希望函数作为输出返回的值（例如变量）。</p>
<p>默认情况下，如果不指定返回值类型，默认返回值类型是
<code>Unit</code>。<code>Unit</code>
表示函数并不会返回值。<code>Unit</code> 相当于其他语言中的 void
返回值类型（在 Java 和 C 中为 <code>void</code>；在 Python 中为
<code>None</code> 等）。任何不返回值的函数都会隐式返回
<code>Unit</code>。 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    birthdayGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">birthdayGreeting</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, Rover!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are now 5 years old!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">43</span></span><br><span class="line">    <span class="keyword">val</span> answerString = <span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answerString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中的函数名为
<code>generateAnswerString</code>。它不接受任何输入。它会输出
<code>String</code>类型的结果。要调用函数，请使用函数名称，后跟调用运算符
(<code>()</code>)。在下面的示例中，使用
<code>generateAnswerString()</code> 的结果对 <code>answerString</code>
变量进行了初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = generateAnswerString()</span><br></pre></td></tr></table></figure>
<p>函数可以接受参数输入，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">43</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明函数时，可以指定任意数量的参数及其类型。在上面的示例中，
<code>generateAnswerString()</code> 接受一个名为
<code>countThreshold</code> 的 <code>Int</code>
类型的参数。在函数中，可以使用参数的名称来引用参数。</p>
<p>调用此函数时，必须在函数调用的圆括号内添加一个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = generateAnswerString(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<h4 id="简化函数声明">简化函数声明</h4>
<p><code>generateAnswerString()</code>
是一个相当简单的函数。该函数声明一个变量，然后立即返回结果。函数返回单个表达式的结果时，可以通过直接返回函数中包含的
<code>if-else</code>
表达式的结果来跳过声明局部变量，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以将 return 关键字替换为赋值运算符：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String = <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认参数">默认参数</h4>
<p>Kotlin 支持为函数参数提供默认值，从而在调用函数时可以省略这些参数：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;World&quot;</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(greet()) <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">println(greet(<span class="string">&quot;Kotlin&quot;</span>)) <span class="comment">// 输出: Hello, Kotlin!</span></span><br></pre></td></tr></table></figure></p>
<h4 id="命名参数">命名参数</h4>
<p>在调用函数时，可以使用命名参数来明确指定每个参数的值。这在具有多个参数的函数中非常有用：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">displayMessage</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>, city: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span>, <span class="variable">$age</span> years old, from <span class="variable">$city</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名参数</span></span><br><span class="line">displayMessage(name = <span class="string">&quot;Alice&quot;</span>, age = <span class="number">30</span>, city = <span class="string">&quot;New York&quot;</span>)</span><br><span class="line">displayMessage(city = <span class="string">&quot;Los Angeles&quot;</span>, name = <span class="string">&quot;Bob&quot;</span>, age = <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
通过命名参数，可以在调用函数时以任意顺序传递参数。这种方式尤其在参数较多或者参数具有默认值时显得非常有用。</p>
<h4 id="将函数存储在变量中">将函数存储在变量中</h4>
<p>直观上，我们会这样做，但实际上这个是一个错误的例子： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = trick</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">trick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为 Kotlin 编译器会将 trick 识别为 trick()
函数的名称，但它想让调用该函数，而不是将其分配给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function invocation &#x27;trick()&#x27; expected</span><br></pre></td></tr></table></figure>
<p>可以使用函数引用算符(<code>::</code>),具体使用如下：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = ::trick</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">trick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-lambda-表达式重新定义函数">使用 lambda
表达式重新定义函数</h4>
<p>lambda 表达式提供了简洁的语法来定义函数，无需使用 <code>fun</code>
关键字。可以直接将 lambda
表达式存储在变量中，无需对其他函数进行函数引用。</p>
<p>在赋值运算符（<code>=</code>）前面，要添加 <code>val</code> 或
<code>var</code>
关键字，后跟变量名称，以供在调用函数时使用。赋值运算符（<code>=</code>）后面是
lambda
表达式，它由一对大括号构成，而大括号中的内容则构成函数正文。语法如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val &lt;variable name&gt; = &#123;</span><br><span class="line">    &lt;function body&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 lambda
表达式定义函数时，有一个引用该函数的变量。还可以像对待任何其他类型一样，将其值分配给其他变量，并使用新变量的名称调用该函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = trick</span><br><span class="line">    trick()</span><br><span class="line">    trickFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> trick = &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会调用函数两次，一次针对 <code>trick()</code>
函数调用，第二次针对 <code>trickFunction()</code> 函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No treats!</span><br><span class="line">No treats!</span><br></pre></td></tr></table></figure>
<h4 id="高阶函数">高阶函数</h4>
<p>一个函数可以将另一个函数当作参数。将其他函数用作参数的函数称为“高阶函数”。此模式对组件之间的通信（其方式与在
Java 中使用回调接口相同）很有用。</p>
<p>下面是一个高阶函数的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringMapper</span><span class="params">(str: <span class="type">String</span>, mapper: (<span class="type">String</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Invoke function</span></span><br><span class="line">    <span class="keyword">return</span> mapper(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stringMapper()</code> 函数接受一个 <code>String</code>
以及一个函数，该函数根据传递给它的 <code>String</code> 来推导
<code>Int</code> 值。</p>
<p>要调用 <code>stringMapper()</code>，可以传递一个 <code>String</code>
和一个满足其他输入参数的函数（即，一个将 <code>String</code>
当作输入并输出 <code>Int</code> 的函数），如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">stringMapper(<span class="string">&quot;Android&quot;</span>, &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果匿名函数是在某个函数上定义的最后一个参数，则可以在用于调用该函数的圆括号之外传递它，如以下示例所示：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">stringMapper(<span class="string">&quot;Android&quot;</span>) &#123; input -&gt;</span><br><span class="line">input.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在整个 Kotlin 标准库中可以找到很多匿名函数。如需了解详情，请参阅<a
href="https://kotlinlang.org/docs/lambdas.html">高阶函数和
Lambda</a>。</p>
<h3 id="类">类</h3>
<p>到目前为止提到的所有类型都已内置在 Kotlin
编程语言中。如果希望添加自己的自定义类型，可以使用 <code>class</code>
关键字来定义，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br></pre></td></tr></table></figure>
<p>类名称采用 <code>PascalCase</code>
大小写形式编写，因此每个单词都以大写字母开头，且各个单词之间没有空格。以“SmartDevice”为例，每个单词的第一个字母都大写，且单词之间没有空格。</p>
<h4 id="属性">属性</h4>
<p>类使用属性来表示状态。属性是类级变量，可以包含 getter、setter
和后备字段。由于汽车需要轮子来驱动，因此可以添加 <code>Wheel</code>
对象的列表作为 <code>Car</code> 的属性，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> wheels = listOf&lt;Wheel&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>wheels</code> 是一个
<code>public val</code>，这意味着，可以从 <code>Car</code> 类外部访问
<code>wheels</code>，并且不能为其重新赋值。如果要获取 <code>Car</code>
的实例，必须先调用其构造函数。这样，便可以访问它的任何可访问属性。对于这种初始化的方式必须要配一个初始值，否则无法通过编译。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> car = Car() <span class="comment">// construct a Car</span></span><br><span class="line"><span class="keyword">val</span> wheels = car.wheels <span class="comment">// retrieve the wheels value from the Car</span></span><br></pre></td></tr></table></figure>
<h5 id="构造函数">构造函数</h5>
<h6 id="默认构造函数">默认构造函数</h6>
<p>默认构造函数不含形参。定义默认构造函数的做法如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Android TV&quot;</span></span><br><span class="line">    <span class="keyword">val</span> category = <span class="string">&quot;Entertainment&quot;</span></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin
旨在简化代码，因此，如果构造函数中没有任何注解或可见性修饰符，可以移除
<code>constructor</code>
关键字。如果构造函数中没有任何形参，还可以移除圆括号，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Android TV&quot;</span></span><br><span class="line">    <span class="keyword">val</span> category = <span class="string">&quot;Entertainment&quot;</span></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin
编译器会自动生成默认构造函数。不会在自己的代码中看到自动生成的默认构造函数，因为编译器会在后台进行添加。</p>
<h6 id="定义形参化构造函数">定义形参化构造函数</h6>
<p>在 <code>SmartDevice</code> 类中，<code>name</code> 和
<code>category</code> 属性不可变。需要确保 <code>SmartDevice</code>
类的所有实例初始化 <code>name</code> 和 <code>category</code>
属性。在当前实现中，<code>name</code> 和 <code>category</code>
属性的值都采用硬编码。也就是说，所有智能设备都是以
<code>"Android TV"</code> 字符串命名，并使用
<code>"Entertainment"</code> 字符串进行分类。</p>
<p>若要保持不变性，同时避免使用硬编码值，可以使用形参化构造函数进行初始化：</p>
<ul>
<li>在 <code>SmartDevice</code> 类中，将 <code>name</code> 和
<code>category</code> 属性移至构造函数中，且不赋予默认值：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> category: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Smart device is turned on.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Smart device is turned off.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，该构造函数可接受形参来设置其属性，因此，为此类实例化对象的方式也会随之更改。实例化对象的完整语法如下图所示：</p>
<p>代码表示形式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SmartDevice(<span class="string">&quot;Android TV&quot;</span>, <span class="string">&quot;Entertainment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>构造函数的这两个实参都是字符串，因此我们不清楚应该为哪个形参赋值。解决此问题的做法与传递函数实参的方式类似，只需创建包含具名实参的构造函数即可，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SmartDevice(name = <span class="string">&quot;Android TV&quot;</span>, category = <span class="string">&quot;Entertainment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Kotlin 中的构造函数主要有两类：</p>
<ul>
<li><strong>主要构造函数</strong>：一个类只能有一个主要构造函数（在类标头中定义）。主要构造函数可以是默认构造函数，也可以是形参化构造函数。主要构造函数没有主体，表示其中不能包含任何代码。</li>
<li><strong>辅助构造函数</strong>：一个类可以有多个辅助构造函数。可以定义包含形参或不含形参的辅助构造函数。辅助构造函数可以初始化类，具有包含初始化逻辑的主体。如果类有主要构造函数，则每个辅助构造函数都需要初始化该主要构造函数。</li>
</ul>
<p>辅助构造函数包含在类的主体中，其语法包括以下三个部分：</p>
<ul>
<li><strong>辅助构造函数声明</strong>：辅助构造函数定义以
<code>constructor</code>
关键字开头，后跟圆括号。可视情况在圆括号中包含辅助构造函数所需的形参。</li>
<li><strong>主要构造函数初始化</strong>：初始化以冒号开头，后面依次跟
<code>this</code>
关键字和一对圆括号。可视情况在圆括号中包含主要构造函数所需的形参。</li>
<li><strong>辅助构造函数主体</strong>：在主要构造函数的初始化后跟一对大括号，其中包含辅助构造函数的主体。</li>
</ul>
<p>语法如下所示： <img src="/images/kotlin/image-4.png"
alt="alt text" /> 这里的this就是调用当前类的主构造函数。</p>
<p>例如，假设想集成由智能设备提供商开发的 API。不过，该 API 会返回
<code>Int</code>
类型的状态代码来指明初始设备状态。如果设备处于离线状态，该 API 会返回
<code>0</code> 值；如果设备处于在线状态，则返回 <code>1</code>
值。对于任何其他整数值，系统会将状态视为“未知”。可以在
<code>SmartDevice</code> 类中创建辅助构造函数，以将此
<code>statusCode</code> 形参转换为字符串表示形式，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> category: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, category: String, statusCode: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, category) &#123;</span><br><span class="line">        deviceStatus = <span class="keyword">when</span> (statusCode) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; <span class="string">&quot;offline&quot;</span></span><br><span class="line">            <span class="number">1</span> -&gt; <span class="string">&quot;online&quot;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&quot;unknown&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="getter">Getter</h5>
<p>Getter
方法用于获取对象的属性值。它通常是一个没有参数的方法，当调用它时，它返回对象的某个属性的值。Getter
方法名通常以 <code>get</code> 开头，后接属性的名称。</p>
<p>示例： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field <span class="comment">// getter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    println(person.name) <span class="comment">// 调用 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>name</code> 属性有一个默认的 getter 方法，它返回
<code>field</code>（即 <code>name</code> 属性的值）。</p>
<h5 id="setter">Setter</h5>
<p>Setter
方法用于设置对象的属性值。它通常是一个接收一个参数的方法，该参数是要赋给属性的新值。Setter
方法名通常以 <code>set</code> 开头，后接属性的名称。</p>
<p>示例： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value <span class="comment">// setter</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.name = <span class="string">&quot;Alice&quot;</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>name</code> 属性有一个默认的 setter
方法，它接收一个参数 <code>value</code>，并将 <code>field</code>（即
<code>name</code> 属性的值）设置为这个参数。</p>
<p>以下是一个包含 getter 和 setter 的完整示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brand: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            println(<span class="string">&quot;Getting the brand&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> field</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">&quot;Setting the brand to <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> car = Car()</span><br><span class="line">    car.brand = <span class="string">&quot;Toyota&quot;</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(car.brand)   <span class="comment">// 调用 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>brand</code> 属性有自定义的 getter 和 setter
方法，这些方法在访问和修改属性值时会打印日志信息。</p>
<p>通过使用 getter 和 setter
方法，可以在访问和修改对象属性时添加额外的逻辑，例如数据验证、日志记录等。</p>
<h5 id="使用后备字段">使用后备字段</h5>
<p>Kotlin 自动为每个属性生成一个后备字段，称为
<code>field</code>。可以在 getter 和 setter 中使用 <code>field</code>
来访问和修改属性的值。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                field = value <span class="comment">// 使用后备字段</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Age cannot be negative&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.age = <span class="number">25</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(person.age) <span class="comment">// 调用 getter 方法</span></span><br><span class="line">    person.age = -<span class="number">5</span> <span class="comment">// 试图设置一个负数，将失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>age</code> 属性的 setter 方法包含一个检查，确保
<code>age</code> 非负。如果尝试设置负数，会打印一条错误消息。</p>
<h4 id="封装">封装</h4>
<p>封装是面向对象编程的核心概念之一。在 Kotlin
中，封装通过将对象的状态（属性）和行为（方法）封装在类中，并控制对这些属性和方法的访问来实现。封装有助于保护对象的内部状态，并提供一种受控的方式来访问或修改该状态。</p>
<h5 id="属性的可见性">属性的可见性</h5>
<p>Kotlin 提供了四种可见性修饰符来控制属性和方法的访问权限：</p>
<ul>
<li><code>public</code>：默认修饰符，任何地方都可以访问。</li>
<li><code>internal</code>：在模块内可见。</li>
<li><code>protected</code>：在类及其子类内可见。</li>
<li><code>private</code>：仅在类内可见。</li>
</ul>
<p>以下是一个示例，展示了如何使用可见性修饰符：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> engine = Engine()</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> wheels = listOf&lt;Wheel&gt;()</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> brand = <span class="string">&quot;Toyota&quot;</span></span><br><span class="line">    <span class="keyword">val</span> model = <span class="string">&quot;Corolla&quot;</span> <span class="comment">// 默认是 public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中： - <code>engine</code> 属性是 <code>private</code>
的，仅在 <code>Car</code> 类内可见。 - <code>wheels</code> 属性是
<code>protected</code> 的，在 <code>Car</code> 类及其子类内可见。 -
<code>brand</code> 属性是 <code>internal</code> 的，在同一模块内可见。 -
<code>model</code> 属性是 <code>public</code>
的，任何地方都可以访问。</p>
<blockquote>
<p><strong>模块</strong>： <a
href="https://developer.android.google.cn/studio/projects?hl=zh-cn#ApplicationModules">模块</a>
是源文件和构建设置的集合，可让将项目划分为独立的功能单元的项目可以包含一个或多个模块。可以独立构建、测试和调试每个模块。</p>
<p>软件包就像是用来对相关类进行分组的目录或文件夹，模块则是用来为应用的源代码、资源文件和应用级设置提供容器。一个模块可以包含多个软件包。</p>
</blockquote>
<p>类似的，我们可以为方法，构造函数，类指定可见性修饰符 ##### Setter 和
Getter 的可见性</p>
<p>可以分别为属性的 getter 和 setter
指定不同的可见性修饰符。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// setter 是 private 的，只有类内部可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    println(person.name) <span class="comment">// 可以访问 getter</span></span><br><span class="line">    <span class="comment">// person.name = &quot;Alice&quot; // 无法访问 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>name</code> 属性的 setter 方法是
<code>private</code> 的，因此只能在 <code>Person</code> 类内部修改。</p>
<h5 id="数据类">数据类</h5>
<p>Kotlin 提供了数据类来简化封装数据的工作。数据类自动生成了
<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>copy</code>
等方法。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    println(user.name) <span class="comment">// 访问属性</span></span><br><span class="line">    println(user) <span class="comment">// 调用 toString 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>User</code>
是一个数据类，自动生成了常用方法，使得数据封装更加简洁。</p>
<h4 id="继承">继承</h4>
<p>在 Kotlin
中，继承是实现代码重用和构建层次结构的关键机制。通过继承，一个类可以继承另一个类的属性和方法，从而扩展其功能。</p>
<h5 id="基本概念">基本概念</h5>
<p>在 Kotlin 中，所有类默认都是 <code>final</code>
的，这意味着它们不能被继承。如果希望一个类可以被继承，需要使用
<code>open</code> 关键字来修饰该类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建子类">创建子类</h5>
<p>子类使用 <code>:</code>
符号继承父类，并调用父类的构造函数。以下示例展示了如何创建一个继承自
<code>Vehicle</code> 类的 <code>Car</code> 类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> brand: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(name: String, brand: String, <span class="keyword">val</span> seats: <span class="built_in">Int</span>) : Vehicle(name, brand)</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类继承了 <code>Vehicle</code>
类，并扩展了一个新的属性 <code>seats</code>。</p>
<h5 id="覆盖属性和方法">覆盖属性和方法</h5>
<p>子类可以覆盖父类的属性和方法。要覆盖属性或方法，需要使用
<code>override</code> 关键字。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The vehicle is accelerating&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is accelerating at <span class="variable">$speed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类覆盖了 <code>Vehicle</code> 类的
<code>speed</code> 属性和 <code>accelerate</code> 方法。</p>
<h5 id="使用-super-关键字">使用 <code>super</code> 关键字</h5>
<p><code>super</code>
关键字用于调用父类的属性和方法。以下示例展示了如何在子类中使用
<code>super</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Vehicle is starting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.start()</span><br><span class="line">        println(<span class="string">&quot;Car is starting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类的 <code>start</code> 方法调用了
<code>Vehicle</code> 类的 <code>start</code>
方法，然后执行了自己的逻辑。</p>
<h5 id="继承和构造函数">继承和构造函数</h5>
<p>在继承中，子类的构造函数需要调用父类的构造函数。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(name: String, <span class="keyword">val</span> seats: <span class="built_in">Int</span>) : Vehicle(name)</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类的构造函数调用了
<code>Vehicle</code> 类的构造函数。</p>
<h5 id="抽象类">抽象类</h5>
<p>抽象类是不能被实例化的类，通常用作基类。抽象类可以包含抽象成员（即没有实现的方法），需要在子类中实现这些成员。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is accelerating at <span class="variable">$speed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Vehicle</code> 类是一个抽象类，包含一个抽象属性
<code>speed</code> 和一个抽象方法
<code>accelerate</code>。<code>Car</code> 类继承自 <code>Vehicle</code>
并实现了这些抽象成员。</p>
<h5 id="接口">接口</h5>
<p>接口是一种特殊的类，可以包含抽象方法和具体方法。类可以实现一个或多个接口。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> maxSpeed: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Drivable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> maxSpeed: <span class="built_in">Int</span> = <span class="number">120</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is driving at a maximum speed of <span class="variable">$maxSpeed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Drivable</code> 接口定义了一个属性
<code>maxSpeed</code> 和一个方法 <code>drive</code>。<code>Car</code>
类实现了 <code>Drivable</code> 接口，并提供了这些成员的实现。</p>
<h5 id="多继承">多继承</h5>
<p>Kotlin
不支持多继承，但可以通过实现多个接口来实现类似的功能。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingCar</span> : <span class="type">Drivable</span>, <span class="type">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The flying car is driving&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The flying car is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>FlyingCar</code> 类实现了 <code>Drivable</code>
和 <code>Flyable</code> 接口。</p>
<h3 id="null-安全">Null 安全</h3>
<p>在某些编程语言中，可以声明引用类型变量而不提供初始值，这些变量通常包含
<code>null</code> 值。默认情况下，Kotlin 中的变量不能持有
<code>null</code> 值。这意味着以下代码段是无效的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">val</span> languageName: String = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>如果需要变量持有 <code>null</code> 值，必须显式将其声明为可为
<code>null</code> 类型。可以在类型后面加上
<code>?</code>，将变量指定为可为 <code>null</code>，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>指定为 <code>String?</code> 类型后，可以为 <code>languageName</code>
赋值为 <code>String</code> 或 <code>null</code>。</p>
<h4 id="使用可为-null-的变量">使用可为 null 的变量</h4>
<h5 id="初始化为null">初始化为null：</h5>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> favoriteSinger = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重新赋值为null">重新赋值为null</h5>
<p>错误例子： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    favoriteSinger = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 正确的写法： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger)</span><br><span class="line"></span><br><span class="line">    favoriteSinger = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="处理可为-null-的变量">处理可为 null 的变量</h4>
<p>继续上面的例子,如果我们想要访问可以为null的变量的属性，一个错误的例子如下：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个时候我们会遇到这样的报错： <img
src="/images/kotlin/image-2.png" alt="alt text" /> Kotlin
会刻意应用语法规则，以实现 <code>null</code> 安全，即保证不会意外调用
<code>null</code> 变量。但这并不表示变量不能为
<code>null</code>；而是表示，在访问某个变量的成员时，则该变量不能为
<code>null</code>。</p>
<p>如果在应用运行时访问 <code>null</code> 变量的成员（称为
<code>null</code> 引用），应用会因 <code>null</code>
变量不含任何属性或方法而崩溃。此类崩溃称为“运行时错误”，即在代码完成编译和运行后发生的错误。</p>
<p>由于 Kotlin 具有 <code>null</code> 安全特性，因此 Kotlin
编译器会对可为 <code>null</code> 类型强制执行 <code>null</code>
检查，以免发生此类运行时错误。“Null 检查”是指在访问变量并将其视为不可为
<code>null</code> 类型之前，检查该变量是否为 <code>null</code>
的过程。如果想将可为 <code>null</code> 的值用作不可为 <code>null</code>
类型，则需要明确执行 <code>null</code> 检查。</p>
<p>在此示例中，系统不允许直接引用 <code>favoriteSinger</code> 变量的
<code>length</code> 属性，因为该变量有可能是
<code>null</code>，因此代码在编译时失败。</p>
<p>接下来，将会介绍用来处理可为 <code>null</code>
类型的各种技巧和运算符。 ##### 使用 <code>?.</code> 安全调用运算符</p>
<p>可以使用 <code>?.</code> 安全调用运算符访问可为 null
变量的方法或属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nullable variable&gt; ?. &lt;method/property&gt;</span><br></pre></td></tr></table></figure>
<p>如需使用 <code>?.</code>
安全调用运算符访问方法或属性，请在变量名称后面添加 <code>?</code>
符号，并使用 <code>.</code> 表示法访问方法或属性。 <code>?.</code>
安全调用运算符可让更安全地访问可为 null 的变量，因为 Kotlin
编译器会阻止变量成员为访问 <code>null</code>
引用而进行的任何尝试，并针对访问的成员返回 <code>null</code>。</p>
<p>如需安全地访问可为 null 的 <code>favoriteSinger</code>
变量的属性，请按以下步骤操作：</p>
<ol type="1">
<li>在 <code>println()</code> 语句中，将 <code>.</code> 运算符替换为
<code>?.</code> 安全调用运算符：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger?.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>运行此程序，结果为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>将 <code>favoriteSinger</code> 变量重新赋予
<code>null</code>，然后运行此程序： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger?.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行此程序，结果为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>也就说，如果尝试访问<code>null</code>变量的<code>length</code>属性，该程序也不会崩溃，只会返回<code>null</code></p>
<h5 id="使用-非-null-断言运算符">使用 <code>!!</code> 非 null
断言运算符</h5>
<p>还可以使用 <code>!!</code> 非 null 断言运算符来访问可为 null
的变量的方法或属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nullable variable&gt; !!. &lt;method/property&gt;</span><br></pre></td></tr></table></figure>
<p>需要在可为 null 的变量后面添加 <code>!!</code> 非 null
断言运算符，之后再跟 <code>.</code>
运算符，最后添加不含任何空格的方法或属性。顾名思义，如果使用
<code>!!</code> 非 null 断言运算符，即表示断言变量的值不是
<code>null</code>，无论该变量是否为该值都应如此。</p>
<p>与 <code>?.</code> 安全调用运算符不同，当可为 null 的变量确实为
<code>null</code> 时，使用 <code>!!</code> 非 null
断言运算符可能会导致系统抛出 <code>NullPointerException</code>
错误。因此，只有在变量始终为不可为 <code>null</code>
或设置了适当的异常处理时，才应使用该断言运算符。如果异常未得到处理，便会导致运行时错误。</p>
<p>如需使用 <code>!!</code> 非 <code>null</code> 断言运算符访问
<code>favoriteSinger</code> 变量的属性，请按以下步骤操作：</p>
<ol type="1">
<li>为 <code>favoriteSinger</code> 变量重新赋予喜爱歌手的名称，然后在
<code>println()</code> 语句中将 <code>?.</code> 安全调用运算符替换为
<code>!!</code> 非 null 断言运算符：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger!!.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>运行此程序，然后验证输出是否符合预期：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>为 <code>favoriteSinger</code> 变量重新赋予
<code>null</code>，然后运行此程序：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger!!.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会显示 <code>NullPointerException</code> 错误，内容如下：</p>
<figure>
<img src="/images/kotlin/image-3.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>此 Kotlin 错误显示程序在执行期间崩溃。因此，除非确定变量不为
<code>null</code>，否则不建议使用 <code>!!</code> 非 null
断言运算符。</p>
<h5 id="使用-ifelse-条件">使用 <code>if/else</code> 条件</h5>
<p>可以在 <code>if/else</code> 条件中使用 <code>if</code> 分支来执行
<code>null</code> 检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nullable variable&gt; != null</span><br></pre></td></tr></table></figure>
<p>将 <code>null</code> 检查与 <code>if/else</code>
语句结合使用具有以下优点：</p>
<ul>
<li><code>nullableVariable != null</code> 表达式的 <code>null</code>
检查会被用作 <code>if</code> 条件。</li>
<li><code>if</code> 分支中会假定变量不可为
<code>null</code>。因此，在这个主体中，可以随意访问变量的方法或属性，就像变量是不可为
<code>null</code> 一般，而不必使用 <code>!!</code> 安全调用运算符。</li>
<li><code>else</code> 分支中会假定变量为
<code>null</code>。因此，在这个主体中，可以添加应在变量为
<code>null</code> 时运行的语句。<code>else</code> 分支是可选的。对
<code>null</code> 检查失败时，只能使用 <code>if</code> 条件来运行
<code>null</code> 检查，而不执行默认操作。</li>
</ul>
<p>如果有多行代码使用可为 <code>null</code> 的变量，那么将
<code>null</code> 检查与 <code>if</code>
条件搭配使用会更方便。相比之下，<code>?.</code>
安全调用运算符更适用于对可为 <code>null</code> 变量的单次引用。</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预期的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of characters in your favorite singer&#x27;s name is 5.</span><br></pre></td></tr></table></figure>
<p>请注意，由于会在 <code>null</code> 检查之后访问 <code>if</code>
分支中的 <code>length</code> 方法，因此可以直接使用 <code>.</code>
运算符访问名称的长度方法。同样，Kotlin 编译器知道
<code>favoriteSinger</code> 变量绝不可能为
<code>null</code>，因此允许直接访问属性。</p>
<p>可添加一个 <code>else</code> 分支，以处理歌手名称为 <code>null</code>
的情况：</p>
<p>在 <code>else</code> 分支的主体中，添加会接受
<code>You didn't input a name.</code> 字符串的 <code>println</code>
语句：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;You didn&#x27;t input a name.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为 <code>favoriteSinger</code> 变量赋予
<code>null</code>，然后运行此程序：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;You didn&#x27;t input a name.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出符合预期，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You didn&#x27;t input a name.</span><br></pre></td></tr></table></figure>
<h5 id="使用-elvis-运算符">使用 <code>?:</code> Elvis 运算符</h5>
<p><code>?:</code> Elvis 运算符可以与 <code>?.</code>
安全调用运算符搭配使用。如果搭配使用 <code>?:</code> Elvis
运算符，便可以在 <code>?.</code> 安全调用运算符返回 <code>null</code>
时添加默认值。这与 <code>if/else</code> 表达式类似，但更为常用。</p>
<p>如果该变量不为 <code>null</code>，则执行 <code>?.</code> Elvis
运算符之前的表达式；如果变量为 <code>null</code>，则执行 <code>?:</code>
Elvis 运算符之后的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val &lt;name&gt; = &lt;nullable variable&gt; ?. &lt;method/property&gt; ?: &lt;default value&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>length</code> 属性之后，添加后跟的值 <code>0</code> 的
<code>?:</code> Elvis 运算符，然后运行此程序：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lengthOfName = favoriteSinger?.length ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="variable">$lengthOfName</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出会与之前的输出相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of characters in your favorite singer&#x27;s name is 5.</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2024/10/20/Hexo/</url>
    <content><![CDATA[<p>过一阵发现想要新建一个帖子的时候，已经把命令忘记了，所以记录一下。
<span id="more"></span></p>
<h2 id="新建一个帖子">新建一个帖子</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;Hexo&quot;</span><br></pre></td></tr></table></figure>
<h2 id="生成静态文件">生成静态文件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h2 id="部署网站">部署网站</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>FTP GUI Videos</title>
    <url>/2024/10/20/FTP-GUI-Videos/</url>
    <content><![CDATA[<p>客户端GUI较为清晰版的视频。 <span id="more"></span>
<video width="320" height="240" controls>
<source src="/images/FTP/2.mp4" type="video/mp4"> Your browser does not
support the video tag. </video></p>
<p>由于需要测试不阻塞主界面，因此我们把每次上传和下载的读取都仅仅读取 1
个，才有机会测试出不阻塞。 <video width="320" height="240" controls>
<source src="/images/FTP/1.mp4" type="video/mp4"> Your browser does not
support the video tag. </video></p>
]]></content>
  </entry>
  <entry>
    <title>GitHub PAT</title>
    <url>/2024/11/11/GitHub-PAT/</url>
    <content><![CDATA[<p>生成github PAT的流程 <span id="more"></span> 1. Settings → Developer Settings →
Personal Access Token → Tokens (classic) → Generate New Token 2.
加入Note，勾选repo，admin:repo_hook等权限 3. For Linux, you need to
configure the local GIT client with a username and email address,
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;your_github_username&quot;</span><br><span class="line">$ git config --global user.email &quot;your_github_email&quot;</span><br></pre></td></tr></table></figure> 4. Once GIT is configured, we can begin using it to access
GitHub. Example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/YOUR-USERNAME/YOUR-REPOSITORY</span><br><span class="line"> &gt; Cloning into `YOUR-REPOSITORY`...</span><br><span class="line"> Username: &lt;type your username&gt;</span><br><span class="line"> Password: &lt;type your password or personal access token (GitHub)</span><br></pre></td></tr></table></figure> 5. Now cache the given record in your
computer to remembers the token: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure> 6. If needed, anytime you
can delete the cache record by: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global --unset credential.helper</span><br><span class="line"> $ git config --system --unset credential.helper</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
</search>
