<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin 介绍">
<meta property="og:url" content="http://example.com/2024/07/18/kotlin/index.html">
<meta property="og:site_name" content="Xuu&#39;s Blog">
<meta property="og:description" content="此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/kotlin/image.png">
<meta property="og:image" content="http://example.com/images/kotlin/image-4.png">
<meta property="og:image" content="http://example.com/images/kotlin/image-3.png">
<meta property="article:published_time" content="2024-07-18T12:58:51.518Z">
<meta property="article:modified_time" content="2024-10-03T13:35:15.713Z">
<meta property="article:author" content="Xuu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/kotlin/image.png">

<link rel="canonical" href="http://example.com/2024/07/18/kotlin/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Kotlin 介绍 | Xuu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xuu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/18/kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xuu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xuu's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kotlin 介绍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-18 20:58:51" itemprop="dateCreated datePublished" datetime="2024-07-18T20:58:51+08:00">2024-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-03 21:35:15" itemprop="dateModified" datetime="2024-10-03T21:35:15+08:00">2024-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>此文章是暑陪的时候写的，但是实际上就是参考官网的教程copy了一份。
<span id="more"></span> ## Kotlin 介绍</p>
<p>Kotlin 是一种现代且成熟的编程语言，由 JetBrains 公司于 2011
年设计和开发，并在 2016 年正式发布。在 2019 年的 Google I/O
大会上，Google 宣布 Kotlin 将成为 Android 开发的首选语言。包括 Google
地图、Google Home、Play、Google 云端硬盘和 Google
信息等应用。其中一个成功案例来自 Google Home
团队，他们将新功能开发工作迁移到 Kotlin 后，代码库大小减少了 33%，NPE
崩溃次数减少了 30%。Kotlin
以其简洁性和强大的功能而闻名，不仅能减少常见的代码错误，还能轻松集成到现有的应用程序中。如果打算构建
Android 应用，建议从 Kotlin 开始，充分利用其一流的功能。</p>
<p>开发者倾向于使用 Kotlin 的原因主要有以下几个：</p>
<ul>
<li><strong>富有表现力且简洁</strong>：使用更少的代码实现更多的功能，减少样板代码，表达更加清晰。</li>
<li><strong>更安全的代码</strong>：Kotlin
提供许多语言特性，帮助避免空指针异常等常见的编程错误。</li>
<li><strong>高度互操作</strong>：Kotlin 与 Java 完全互操作，可以在
Kotlin 代码中调用 Java 代码，或在 Java 代码中调用 Kotlin
代码，让可以在项目中无缝添加 Kotlin 代码。</li>
</ul>
<h2 id="kotlin-语言基础">Kotlin 语言基础</h2>
<p>此教程主要用于Kotlin速成，快速上手。 <a
target="_blank" rel="noopener" href="https://play.kotlinlang.org/">在线kotlin</a>编辑器 ###
变量声明</p>
<p>在 Kotlin 中，变量的声明采用两种不同的关键字：<code>val</code> 和
<code>var</code>。</p>
<ul>
<li><code>val</code>
用于声明不可变的变量，即一旦赋值后就不能再更改。</li>
<li><code>var</code> 用于声明可变的变量，即可以多次赋值。</li>
</ul>
<p>例如，<code>count</code> 是一个 <code>Int</code> 类型的变量，初始值为
<code>10</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kotlin/image.png" alt="alt text" />
<code>Int</code> 是表示整数的类型之一。Kotlin 还提供了其他数值类型，如
<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Float</code>
和
<code>Double</code>，以满足不同的数值需求。以下是这些类型的简要说明：</p>
<p>在 Kotlin
中，有一些常见的基本数据类型。下表逐行列明了各种不同的数据类型，并针对每种数据类型提供了可存储数据类型的说明和示例值。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Kotlin 数据类型</th>
<th>可包含的数据类型</th>
<th>字面量值示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>文本</td>
<td>"Add contact"<br>"Search"<br>"Sign in"</td>
</tr>
<tr>
<td>Int</td>
<td>整数</td>
<td>32<br>1293490<br>-59281</td>
</tr>
<tr>
<td>Double</td>
<td>小数</td>
<td>2.0<br>501.0292<br>-31723.99999</td>
</tr>
<tr>
<td>Float</td>
<td>小数 (不如 Double 精确)，数字末尾带有 <code>f</code> 或
<code>F</code></td>
<td>5.0f<br>-1630.209f<br>1.2940278F</td>
</tr>
<tr>
<td>Boolean</td>
<td><code>true</code> 或 <code>false</code>。当只有两个可能的值时,
可使用此数据类型。请注意，<code>true</code> 和 <code>false</code> 是
Kotlin 中的关键字。</td>
<td><code>true</code><br><code>false</code></td>
</tr>
</tbody>
</table>
<p>使用 <code>var</code> 关键字意味着可以重新赋值给
<code>count</code>。例如，可以将 <code>count</code> 的值从
<code>10</code> 改为 <code>15</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">count = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>有些变量的值是不应该更改的。假设有一个名为 <code>languageName</code>
的 <code>String</code> 类型变量，如果希望确保 <code>languageName</code>
的值始终为 “Kotlin”，可以使用 <code>val</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName: String = <span class="string">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>val</code> 和
<code>var</code>，可以明确区分哪些变量的值是可变的，哪些是不可变的。针对不同的需求做出适当的选择。如果变量的值需要改变，则使用
<code>var</code>；否则，使用 <code>val</code>。 #### 编码规范
一些格式设置和编码规范：</p>
<ul>
<li>变量名称应采用驼峰式大小写形式，并以小写字母开头。</li>
<li>在变量声明中指定数据类型时，应在冒号后面添加一个空格。</li>
<li>赋值运算符（=）、加号（+）、减号（-）、乘号（*）、除号（/）等运算符的前后应有空格。</li>
</ul>
<h4 id="注释">注释</h4>
<p>编写代码时，另一个建议遵循的较好做法是添加注释来说明代码的用途。这样做可帮助读者更轻松地理解代码。可以使用两个正斜杠符号
(<code>//</code>)
来指明将相应行中该符号后的剩余文本视为注释，而不要解释为代码。通常的做法是在两个正斜杠符号后添加一个空格。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a comment.</span></span><br></pre></td></tr></table></figure>
<p>也可以在一行代码的中间位置插入注释。在下面的示例中，<code>height = 1</code>
是正常的编码语句。<code>//</code> 之后的所有内容（即
<code>Assume the height is 1 to start with</code>）都会被解释为注释，而不会被视为代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">1</span> <span class="comment">// Assume the height is 1 to start with.</span></span><br></pre></td></tr></table></figure>
<p>对于多行注释而言。具体方法为：使用由正斜杠 (<code>/</code>) 和星号
(<code>*</code>) 组成的 <code>/*</code>
来作为多行注释的开头，在注释的每个新行开头添加一个星号，最后使用由星号和正斜杠符号组成的
<code>*/</code> 作为结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a very long comment that can</span></span><br><span class="line"><span class="comment">* take up multiple lines.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="类型推断">类型推断</h4>
<p>Kotlin
拥有强大的类型推断功能，可以根据初始值自动推断变量的类型，从而简化代码。延续前面的示例，在为
<code>languageName</code> 赋值后，Kotlin
编译器会根据初始值推断其类型。</p>
<p>由于 <code>"Kotlin"</code> 是 <code>String</code>
类型，因此编译器推断 <code>languageName</code> 也为
<code>String</code>。 &gt; 注意：Kotlin
是一种静态类型语言，这意味着类型在编译时解析并且不会改变。</p>
<p>在以下示例中，<code>languageName</code> 被推断为
<code>String</code>，因此只能调用 <code>String</code> 类的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">val</span> upperCaseName = languageName.uppercase() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line">languageName.inc()</span><br></pre></td></tr></table></figure>
<p><code>uppercase()</code>
是一个用于将字符串中的小写字母转换为大写字母的 <code>String</code>
类型方法。由于 Kotlin 编译器已将 <code>languageName</code> 推断为
<code>String</code>，因此可以成功调用
<code>uppercase()</code>。然而，<code>inc()</code> 是一个
<code>Int</code> 类型的方法，用于将数值增加 1，因此不能对
<code>String</code> 类型调用它。通过 Kotlin
的类型推断，可以使代码更加简洁且类型安全。</p>
<h3 id="条件语句">条件语句</h3>
<p>Kotlin 提供了几种实现条件逻辑的机制，其中最常见的是
<code>if-else</code>
语句。这种语句用于基于条件的真伪来执行不同的代码块。语法非常直观：如果
<code>if</code> 关键字后面的表达式求值为
<code>true</code>，则执行该分支中的代码；否则，执行 <code>else</code>
分支中的代码。让我们看一个简单的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer eludes me.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>else if</code>
表示多个条件。这样，就可以在单个条件语句中表示更精细、更复杂的逻辑。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">35</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer is close.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;The answer eludes me.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件语句对于表示有状态的逻辑非常有用，但可能会发现，编写这些语句时会出现重复。在上面的示例中，每个分支都是输出一个
<code>String</code>。为了避免这种重复，Kotlin
提供了条件表达式。最后一个示例可以重新编写如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString: String = <span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;I have the answer.&quot;</span>)</span><br><span class="line">    <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">35</span>) &#123;</span><br><span class="line">    <span class="string">&quot;The answer is close.&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(answerString)</span><br></pre></td></tr></table></figure>
<p>每个条件分支都隐式地返回其最后一行的表达式的结果，因此无需使用
<code>return</code> 关键字。由于全部三个分支的结果都是
<code>String</code> 类型，因此 <code>if-else</code> 表达式的结果也是
<code>String</code> 类型。在本例中，根据 <code>if-else</code>
表达式的结果为 <code>answerString</code>
赋予了一个初始值。利用类型推断可以省略 <code>answerString</code>
的显式类型声明，但为了清楚起见，通常最好添加该声明。</p>
<blockquote>
<p>注意：Kotlin 不包含传统的三元运算符
(<code>?:</code>)，而是倾向于使用条件表达式。这使得代码更加简洁明了。</p>
</blockquote>
<p>随着条件语句的复杂性不断增加，可以考虑将 <code>if-else</code>
表达式替换为 <code>when</code> 表达式，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = <span class="keyword">when</span> &#123;</span><br><span class="line">    count == <span class="number">42</span> -&gt; <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    count &gt; <span class="number">35</span> -&gt; <span class="string">&quot;The answer is close.&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(answerString)</span><br></pre></td></tr></table></figure>
<p><code>when</code> 表达式中每个分支都由一个条件、一个箭头
(<code>-&gt;</code>) 和一个结果来表示。如果分支头左侧的条件求值为
<code>true</code>，则返回右侧的表达式结果。请注意，执行并不是从一个分支跳转到下一个分支。<code>when</code>
表达式示例中的代码在功能上与上一个示例中的代码等效，但结构更为清晰。</p>
<p>此外，<code>when</code>
表达式不仅可以用于简单的条件判断，还可以用于更复杂的模式匹配。例如，可以根据变量的类型执行不同的操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkType</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">&quot;This is a String of length <span class="subst">$&#123;obj.length&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;This is an Integer with value <span class="variable">$obj</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构">循环结构</h3>
<p>Kotlin 提供了几种实现循环的机制，其中最常见的是 <code>for</code>
循环和 <code>while</code> 循环。</p>
<h4 id="for-循环"><code>for</code> 循环</h4>
<p><code>for</code>
循环用于遍历集合、数组或区间，并对每个元素执行指定的操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>numbers</code>
是一个包含整数的列表。<code>for</code>
循环将依次遍历列表中的每个元素，并将当前元素赋值给 <code>number</code>
变量，然后执行循环体中的代码块。</p>
<p>可以使用 <code>for</code> 循环遍历任何实现了 <code>Iterable</code>
接口的对象，例如集合、数组或区间。以下是一些使用 <code>for</code>
循环的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历区间</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个示例中，<code>for</code> 循环遍历数组 <code>array</code>
中的每个元素，并将当前元素赋值给 <code>element</code>
变量。第二个示例展示了如何遍历一个从 1 到 5 的区间。</p>
<p>有时，不仅需要访问元素的值，还需要访问元素的索引。这时可以使用
<code>withIndex</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;Element at <span class="variable">$index</span> is <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>withIndex</code> 函数返回一个包含索引和值的
<code>IndexedValue</code> 对象。通过解构声明，可以将索引和值分别赋值给
<code>index</code> 和 <code>value</code> 变量。</p>
<p>Kotlin 还提供了一种更简洁的方式来遍历区间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>1 until 5</code> 表示从 1 到 4 的半开区间，不包括
5。在循环中，<code>i</code> 的值依次为 1, 2, 3, 4。</p>
<p>如果需要以特定步长遍历区间，可以使用 <code>step</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>1..10 step 2</code> 表示从 1 到 10
的区间，步长为 2。循环体中的 <code>i</code> 将依次取值 1, 3, 5, 7,
9。</p>
<p>此外，还可以使用 <code>downTo</code> 函数以递减顺序遍历区间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>10 downTo 1</code> 表示从 10 到 1
的递减区间。<code>for</code>
循环可以高效地遍历任何类型的集合，并且可以与其他 Kotlin
特性（如解构声明和类型推断）结合使用，以进一步简化代码。</p>
<h4 id="while-循环"><code>while</code> 循环</h4>
<p><code>while</code>
循环用于在给定条件为真时重复执行一段代码。<code>while</code>
循环在每次迭代前都会检查条件，如果条件为真，则执行循环体中的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;Count is <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">    count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>count</code> 变量初始值为 0。<code>while</code>
循环在每次迭代前检查 <code>count &lt; 5</code>
是否为真。如果为真，则执行循环体中的代码，输出当前 <code>count</code>
的值，并将 <code>count</code> 增加 1。循环将一直执行，直到
<code>count</code> 的值不再小于 5。</p>
<p><code>do-while</code> 循环与 <code>while</code>
循环类似，但它会先执行一次循环体中的代码，然后再检查条件。这意味着
<code>do-while</code> 循环至少会执行一次。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Count is <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">    count++</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，即使初始条件为假，<code>do-while</code>
循环也会执行一次循环体中的代码，然后再检查 <code>count &lt; 5</code>
是否为真。</p>
<p>通过合理使用 <code>for</code> 循环和 <code>while</code>
循环，可以简洁、高效地遍历各种集合、数组和区间，并对每个元素执行所需的操作。这些循环结构在编写高效、可维护的代码时非常有用，特别是在处理大量数据或需要重复执行某些操作时。</p>
<h3 id="函数">函数</h3>
<p>可以将相应的表达式封装在一个函数中并调用该函数，而不必在每次需要某个结果时都重复同一系列的表达式。</p>
<p>要声明函数，请使用 <code>fun</code>
关键字，后跟函数名称。定义函数时，可以指定希望其返回的值的数据类型。如果指定返回值类型，只需在圆括号后面添加冒号
(<code>:</code>)，然后在冒号后面添加一个空格和类型名称（例如
<code>Int</code>、<code>String</code>
等）。然后，在返回值类型与左大括号之间添加一个空格。在函数主体中，可以在所有语句之后使用
<code>return</code> 语句指定希望函数返回的值。<code>return</code>
语句包含 <code>return</code>
关键字，后跟希望函数作为输出返回的值（例如变量）。</p>
<p>默认情况下，如果不指定返回值类型，默认返回值类型是
<code>Unit</code>。<code>Unit</code>
表示函数并不会返回值。<code>Unit</code> 相当于其他语言中的 void
返回值类型（在 Java 和 C 中为 <code>void</code>；在 Python 中为
<code>None</code> 等）。任何不返回值的函数都会隐式返回
<code>Unit</code>。 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    birthdayGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">birthdayGreeting</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, Rover!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are now 5 years old!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">43</span></span><br><span class="line">    <span class="keyword">val</span> answerString = <span class="keyword">if</span> (count == <span class="number">42</span>) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answerString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中的函数名为
<code>generateAnswerString</code>。它不接受任何输入。它会输出
<code>String</code>类型的结果。要调用函数，请使用函数名称，后跟调用运算符
(<code>()</code>)。在下面的示例中，使用
<code>generateAnswerString()</code> 的结果对 <code>answerString</code>
变量进行了初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = generateAnswerString()</span><br></pre></td></tr></table></figure>
<p>函数可以接受参数输入，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">43</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明函数时，可以指定任意数量的参数及其类型。在上面的示例中，
<code>generateAnswerString()</code> 接受一个名为
<code>countThreshold</code> 的 <code>Int</code>
类型的参数。在函数中，可以使用参数的名称来引用参数。</p>
<p>调用此函数时，必须在函数调用的圆括号内添加一个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answerString = generateAnswerString(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<h4 id="简化函数声明">简化函数声明</h4>
<p><code>generateAnswerString()</code>
是一个相当简单的函数。该函数声明一个变量，然后立即返回结果。函数返回单个表达式的结果时，可以通过直接返回函数中包含的
<code>if-else</code>
表达式的结果来跳过声明局部变量，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer.&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以将 return 关键字替换为赋值运算符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateAnswerString</span><span class="params">(countThreshold: <span class="type">Int</span>)</span></span>: String = <span class="keyword">if</span> (count &gt; countThreshold) &#123;</span><br><span class="line">        <span class="string">&quot;I have the answer&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;The answer eludes me&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认参数">默认参数</h4>
<p>Kotlin 支持为函数参数提供默认值，从而在调用函数时可以省略这些参数：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;World&quot;</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(greet()) <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">println(greet(<span class="string">&quot;Kotlin&quot;</span>)) <span class="comment">// 输出: Hello, Kotlin!</span></span><br></pre></td></tr></table></figure></p>
<h4 id="命名参数">命名参数</h4>
<p>在调用函数时，可以使用命名参数来明确指定每个参数的值。这在具有多个参数的函数中非常有用：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">displayMessage</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>, city: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span>, <span class="variable">$age</span> years old, from <span class="variable">$city</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名参数</span></span><br><span class="line">displayMessage(name = <span class="string">&quot;Alice&quot;</span>, age = <span class="number">30</span>, city = <span class="string">&quot;New York&quot;</span>)</span><br><span class="line">displayMessage(city = <span class="string">&quot;Los Angeles&quot;</span>, name = <span class="string">&quot;Bob&quot;</span>, age = <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
通过命名参数，可以在调用函数时以任意顺序传递参数。这种方式尤其在参数较多或者参数具有默认值时显得非常有用。</p>
<h4 id="将函数存储在变量中">将函数存储在变量中</h4>
<p>直观上，我们会这样做，但实际上这个是一个错误的例子： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = trick</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">trick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为 Kotlin 编译器会将 trick 识别为 trick()
函数的名称，但它想让调用该函数，而不是将其分配给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function invocation &#x27;trick()&#x27; expected</span><br></pre></td></tr></table></figure>
<p>可以使用函数引用算符(<code>::</code>),具体使用如下：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = ::trick</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">trick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-lambda-表达式重新定义函数">使用 lambda
表达式重新定义函数</h4>
<p>lambda 表达式提供了简洁的语法来定义函数，无需使用 <code>fun</code>
关键字。可以直接将 lambda
表达式存储在变量中，无需对其他函数进行函数引用。</p>
<p>在赋值运算符（<code>=</code>）前面，要添加 <code>val</code> 或
<code>var</code>
关键字，后跟变量名称，以供在调用函数时使用。赋值运算符（<code>=</code>）后面是
lambda
表达式，它由一对大括号构成，而大括号中的内容则构成函数正文。语法如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val &lt;variable name&gt; = &#123;</span><br><span class="line">    &lt;function body&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 lambda
表达式定义函数时，有一个引用该函数的变量。还可以像对待任何其他类型一样，将其值分配给其他变量，并使用新变量的名称调用该函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trickFunction = trick</span><br><span class="line">    trick()</span><br><span class="line">    trickFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> trick = &#123;</span><br><span class="line">    println(<span class="string">&quot;No treats!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会调用函数两次，一次针对 <code>trick()</code>
函数调用，第二次针对 <code>trickFunction()</code> 函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No treats!</span><br><span class="line">No treats!</span><br></pre></td></tr></table></figure>
<h4 id="高阶函数">高阶函数</h4>
<p>一个函数可以将另一个函数当作参数。将其他函数用作参数的函数称为“高阶函数”。此模式对组件之间的通信（其方式与在
Java 中使用回调接口相同）很有用。</p>
<p>下面是一个高阶函数的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringMapper</span><span class="params">(str: <span class="type">String</span>, mapper: (<span class="type">String</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Invoke function</span></span><br><span class="line">    <span class="keyword">return</span> mapper(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stringMapper()</code> 函数接受一个 <code>String</code>
以及一个函数，该函数根据传递给它的 <code>String</code> 来推导
<code>Int</code> 值。</p>
<p>要调用 <code>stringMapper()</code>，可以传递一个 <code>String</code>
和一个满足其他输入参数的函数（即，一个将 <code>String</code>
当作输入并输出 <code>Int</code> 的函数），如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringMapper(<span class="string">&quot;Android&quot;</span>, &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果匿名函数是在某个函数上定义的最后一个参数，则可以在用于调用该函数的圆括号之外传递它，如以下示例所示：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringMapper(<span class="string">&quot;Android&quot;</span>) &#123; input -&gt;</span><br><span class="line">input.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在整个 Kotlin 标准库中可以找到很多匿名函数。如需了解详情，请参阅<a
target="_blank" rel="noopener" href="https://kotlinlang.org/docs/lambdas.html">高阶函数和
Lambda</a>。</p>
<h3 id="类">类</h3>
<p>到目前为止提到的所有类型都已内置在 Kotlin
编程语言中。如果希望添加自己的自定义类型，可以使用 <code>class</code>
关键字来定义，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br></pre></td></tr></table></figure>
<p>类名称采用 <code>PascalCase</code>
大小写形式编写，因此每个单词都以大写字母开头，且各个单词之间没有空格。以“SmartDevice”为例，每个单词的第一个字母都大写，且单词之间没有空格。</p>
<h4 id="属性">属性</h4>
<p>类使用属性来表示状态。属性是类级变量，可以包含 getter、setter
和后备字段。由于汽车需要轮子来驱动，因此可以添加 <code>Wheel</code>
对象的列表作为 <code>Car</code> 的属性，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> wheels = listOf&lt;Wheel&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>wheels</code> 是一个
<code>public val</code>，这意味着，可以从 <code>Car</code> 类外部访问
<code>wheels</code>，并且不能为其重新赋值。如果要获取 <code>Car</code>
的实例，必须先调用其构造函数。这样，便可以访问它的任何可访问属性。对于这种初始化的方式必须要配一个初始值，否则无法通过编译。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> car = Car() <span class="comment">// construct a Car</span></span><br><span class="line"><span class="keyword">val</span> wheels = car.wheels <span class="comment">// retrieve the wheels value from the Car</span></span><br></pre></td></tr></table></figure>
<h5 id="构造函数">构造函数</h5>
<h6 id="默认构造函数">默认构造函数</h6>
<p>默认构造函数不含形参。定义默认构造函数的做法如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Android TV&quot;</span></span><br><span class="line">    <span class="keyword">val</span> category = <span class="string">&quot;Entertainment&quot;</span></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin
旨在简化代码，因此，如果构造函数中没有任何注解或可见性修饰符，可以移除
<code>constructor</code>
关键字。如果构造函数中没有任何形参，还可以移除圆括号，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Android TV&quot;</span></span><br><span class="line">    <span class="keyword">val</span> category = <span class="string">&quot;Entertainment&quot;</span></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin
编译器会自动生成默认构造函数。不会在自己的代码中看到自动生成的默认构造函数，因为编译器会在后台进行添加。</p>
<h6 id="定义形参化构造函数">定义形参化构造函数</h6>
<p>在 <code>SmartDevice</code> 类中，<code>name</code> 和
<code>category</code> 属性不可变。需要确保 <code>SmartDevice</code>
类的所有实例初始化 <code>name</code> 和 <code>category</code>
属性。在当前实现中，<code>name</code> 和 <code>category</code>
属性的值都采用硬编码。也就是说，所有智能设备都是以
<code>"Android TV"</code> 字符串命名，并使用
<code>"Entertainment"</code> 字符串进行分类。</p>
<p>若要保持不变性，同时避免使用硬编码值，可以使用形参化构造函数进行初始化：</p>
<ul>
<li>在 <code>SmartDevice</code> 类中，将 <code>name</code> 和
<code>category</code> 属性移至构造函数中，且不赋予默认值：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> category: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Smart device is turned on.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Smart device is turned off.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，该构造函数可接受形参来设置其属性，因此，为此类实例化对象的方式也会随之更改。实例化对象的完整语法如下图所示：</p>
<p>代码表示形式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartDevice(<span class="string">&quot;Android TV&quot;</span>, <span class="string">&quot;Entertainment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>构造函数的这两个实参都是字符串，因此我们不清楚应该为哪个形参赋值。解决此问题的做法与传递函数实参的方式类似，只需创建包含具名实参的构造函数即可，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartDevice(name = <span class="string">&quot;Android TV&quot;</span>, category = <span class="string">&quot;Entertainment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Kotlin 中的构造函数主要有两类：</p>
<ul>
<li><strong>主要构造函数</strong>：一个类只能有一个主要构造函数（在类标头中定义）。主要构造函数可以是默认构造函数，也可以是形参化构造函数。主要构造函数没有主体，表示其中不能包含任何代码。</li>
<li><strong>辅助构造函数</strong>：一个类可以有多个辅助构造函数。可以定义包含形参或不含形参的辅助构造函数。辅助构造函数可以初始化类，具有包含初始化逻辑的主体。如果类有主要构造函数，则每个辅助构造函数都需要初始化该主要构造函数。</li>
</ul>
<p>辅助构造函数包含在类的主体中，其语法包括以下三个部分：</p>
<ul>
<li><strong>辅助构造函数声明</strong>：辅助构造函数定义以
<code>constructor</code>
关键字开头，后跟圆括号。可视情况在圆括号中包含辅助构造函数所需的形参。</li>
<li><strong>主要构造函数初始化</strong>：初始化以冒号开头，后面依次跟
<code>this</code>
关键字和一对圆括号。可视情况在圆括号中包含主要构造函数所需的形参。</li>
<li><strong>辅助构造函数主体</strong>：在主要构造函数的初始化后跟一对大括号，其中包含辅助构造函数的主体。</li>
</ul>
<p>语法如下所示： <img src="/images/kotlin/image-4.png"
alt="alt text" /> 这里的this就是调用当前类的主构造函数。</p>
<p>例如，假设想集成由智能设备提供商开发的 API。不过，该 API 会返回
<code>Int</code>
类型的状态代码来指明初始设备状态。如果设备处于离线状态，该 API 会返回
<code>0</code> 值；如果设备处于在线状态，则返回 <code>1</code>
值。对于任何其他整数值，系统会将状态视为“未知”。可以在
<code>SmartDevice</code> 类中创建辅助构造函数，以将此
<code>statusCode</code> 形参转换为字符串表示形式，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDevice</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> category: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> deviceStatus = <span class="string">&quot;online&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, category: String, statusCode: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, category) &#123;</span><br><span class="line">        deviceStatus = <span class="keyword">when</span> (statusCode) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; <span class="string">&quot;offline&quot;</span></span><br><span class="line">            <span class="number">1</span> -&gt; <span class="string">&quot;online&quot;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&quot;unknown&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="getter">Getter</h5>
<p>Getter
方法用于获取对象的属性值。它通常是一个没有参数的方法，当调用它时，它返回对象的某个属性的值。Getter
方法名通常以 <code>get</code> 开头，后接属性的名称。</p>
<p>示例： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field <span class="comment">// getter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    println(person.name) <span class="comment">// 调用 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>name</code> 属性有一个默认的 getter 方法，它返回
<code>field</code>（即 <code>name</code> 属性的值）。</p>
<h5 id="setter">Setter</h5>
<p>Setter
方法用于设置对象的属性值。它通常是一个接收一个参数的方法，该参数是要赋给属性的新值。Setter
方法名通常以 <code>set</code> 开头，后接属性的名称。</p>
<p>示例： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value <span class="comment">// setter</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.name = <span class="string">&quot;Alice&quot;</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>name</code> 属性有一个默认的 setter
方法，它接收一个参数 <code>value</code>，并将 <code>field</code>（即
<code>name</code> 属性的值）设置为这个参数。</p>
<p>以下是一个包含 getter 和 setter 的完整示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brand: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            println(<span class="string">&quot;Getting the brand&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> field</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">&quot;Setting the brand to <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> car = Car()</span><br><span class="line">    car.brand = <span class="string">&quot;Toyota&quot;</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(car.brand)   <span class="comment">// 调用 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>brand</code> 属性有自定义的 getter 和 setter
方法，这些方法在访问和修改属性值时会打印日志信息。</p>
<p>通过使用 getter 和 setter
方法，可以在访问和修改对象属性时添加额外的逻辑，例如数据验证、日志记录等。</p>
<h5 id="使用后备字段">使用后备字段</h5>
<p>Kotlin 自动为每个属性生成一个后备字段，称为
<code>field</code>。可以在 getter 和 setter 中使用 <code>field</code>
来访问和修改属性的值。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                field = value <span class="comment">// 使用后备字段</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Age cannot be negative&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.age = <span class="number">25</span> <span class="comment">// 调用 setter 方法</span></span><br><span class="line">    println(person.age) <span class="comment">// 调用 getter 方法</span></span><br><span class="line">    person.age = -<span class="number">5</span> <span class="comment">// 试图设置一个负数，将失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>age</code> 属性的 setter 方法包含一个检查，确保
<code>age</code> 非负。如果尝试设置负数，会打印一条错误消息。</p>
<h4 id="封装">封装</h4>
<p>封装是面向对象编程的核心概念之一。在 Kotlin
中，封装通过将对象的状态（属性）和行为（方法）封装在类中，并控制对这些属性和方法的访问来实现。封装有助于保护对象的内部状态，并提供一种受控的方式来访问或修改该状态。</p>
<h5 id="属性的可见性">属性的可见性</h5>
<p>Kotlin 提供了四种可见性修饰符来控制属性和方法的访问权限：</p>
<ul>
<li><code>public</code>：默认修饰符，任何地方都可以访问。</li>
<li><code>internal</code>：在模块内可见。</li>
<li><code>protected</code>：在类及其子类内可见。</li>
<li><code>private</code>：仅在类内可见。</li>
</ul>
<p>以下是一个示例，展示了如何使用可见性修饰符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> engine = Engine()</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> wheels = listOf&lt;Wheel&gt;()</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> brand = <span class="string">&quot;Toyota&quot;</span></span><br><span class="line">    <span class="keyword">val</span> model = <span class="string">&quot;Corolla&quot;</span> <span class="comment">// 默认是 public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中： - <code>engine</code> 属性是 <code>private</code>
的，仅在 <code>Car</code> 类内可见。 - <code>wheels</code> 属性是
<code>protected</code> 的，在 <code>Car</code> 类及其子类内可见。 -
<code>brand</code> 属性是 <code>internal</code> 的，在同一模块内可见。 -
<code>model</code> 属性是 <code>public</code>
的，任何地方都可以访问。</p>
<blockquote>
<p><strong>模块</strong>： <a
target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/projects?hl=zh-cn#ApplicationModules">模块</a>
是源文件和构建设置的集合，可让将项目划分为独立的功能单元的项目可以包含一个或多个模块。可以独立构建、测试和调试每个模块。</p>
<p>软件包就像是用来对相关类进行分组的目录或文件夹，模块则是用来为应用的源代码、资源文件和应用级设置提供容器。一个模块可以包含多个软件包。</p>
</blockquote>
<p>类似的，我们可以为方法，构造函数，类指定可见性修饰符 ##### Setter 和
Getter 的可见性</p>
<p>可以分别为属性的 getter 和 setter
指定不同的可见性修饰符。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// setter 是 private 的，只有类内部可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    println(person.name) <span class="comment">// 可以访问 getter</span></span><br><span class="line">    <span class="comment">// person.name = &quot;Alice&quot; // 无法访问 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>name</code> 属性的 setter 方法是
<code>private</code> 的，因此只能在 <code>Person</code> 类内部修改。</p>
<h5 id="数据类">数据类</h5>
<p>Kotlin 提供了数据类来简化封装数据的工作。数据类自动生成了
<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>copy</code>
等方法。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    println(user.name) <span class="comment">// 访问属性</span></span><br><span class="line">    println(user) <span class="comment">// 调用 toString 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>User</code>
是一个数据类，自动生成了常用方法，使得数据封装更加简洁。</p>
<h4 id="继承">继承</h4>
<p>在 Kotlin
中，继承是实现代码重用和构建层次结构的关键机制。通过继承，一个类可以继承另一个类的属性和方法，从而扩展其功能。</p>
<h5 id="基本概念">基本概念</h5>
<p>在 Kotlin 中，所有类默认都是 <code>final</code>
的，这意味着它们不能被继承。如果希望一个类可以被继承，需要使用
<code>open</code> 关键字来修饰该类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建子类">创建子类</h5>
<p>子类使用 <code>:</code>
符号继承父类，并调用父类的构造函数。以下示例展示了如何创建一个继承自
<code>Vehicle</code> 类的 <code>Car</code> 类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> brand: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(name: String, brand: String, <span class="keyword">val</span> seats: <span class="built_in">Int</span>) : Vehicle(name, brand)</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类继承了 <code>Vehicle</code>
类，并扩展了一个新的属性 <code>seats</code>。</p>
<h5 id="覆盖属性和方法">覆盖属性和方法</h5>
<p>子类可以覆盖父类的属性和方法。要覆盖属性或方法，需要使用
<code>override</code> 关键字。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The vehicle is accelerating&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is accelerating at <span class="variable">$speed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类覆盖了 <code>Vehicle</code> 类的
<code>speed</code> 属性和 <code>accelerate</code> 方法。</p>
<h5 id="使用-super-关键字">使用 <code>super</code> 关键字</h5>
<p><code>super</code>
关键字用于调用父类的属性和方法。以下示例展示了如何在子类中使用
<code>super</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Vehicle is starting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.start()</span><br><span class="line">        println(<span class="string">&quot;Car is starting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类的 <code>start</code> 方法调用了
<code>Vehicle</code> 类的 <code>start</code>
方法，然后执行了自己的逻辑。</p>
<h5 id="继承和构造函数">继承和构造函数</h5>
<p>在继承中，子类的构造函数需要调用父类的构造函数。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(name: String, <span class="keyword">val</span> seats: <span class="built_in">Int</span>) : Vehicle(name)</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Car</code> 类的构造函数调用了
<code>Vehicle</code> 类的构造函数。</p>
<h5 id="抽象类">抽象类</h5>
<p>抽象类是不能被实例化的类，通常用作基类。抽象类可以包含抽象成员（即没有实现的方法），需要在子类中实现这些成员。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Vehicle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> speed: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is accelerating at <span class="variable">$speed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Vehicle</code> 类是一个抽象类，包含一个抽象属性
<code>speed</code> 和一个抽象方法
<code>accelerate</code>。<code>Car</code> 类继承自 <code>Vehicle</code>
并实现了这些抽象成员。</p>
<h5 id="接口">接口</h5>
<p>接口是一种特殊的类，可以包含抽象方法和具体方法。类可以实现一个或多个接口。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> maxSpeed: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="type">Drivable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> maxSpeed: <span class="built_in">Int</span> = <span class="number">120</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The car is driving at a maximum speed of <span class="variable">$maxSpeed</span> km/h&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>Drivable</code> 接口定义了一个属性
<code>maxSpeed</code> 和一个方法 <code>drive</code>。<code>Car</code>
类实现了 <code>Drivable</code> 接口，并提供了这些成员的实现。</p>
<h5 id="多继承">多继承</h5>
<p>Kotlin
不支持多继承，但可以通过实现多个接口来实现类似的功能。以下是一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingCar</span> : <span class="type">Drivable</span>, <span class="type">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The flying car is driving&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The flying car is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>FlyingCar</code> 类实现了 <code>Drivable</code>
和 <code>Flyable</code> 接口。</p>
<h3 id="null-安全">Null 安全</h3>
<p>在某些编程语言中，可以声明引用类型变量而不提供初始值，这些变量通常包含
<code>null</code> 值。默认情况下，Kotlin 中的变量不能持有
<code>null</code> 值。这意味着以下代码段是无效的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">val</span> languageName: String = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>如果需要变量持有 <code>null</code> 值，必须显式将其声明为可为
<code>null</code> 类型。可以在类型后面加上
<code>?</code>，将变量指定为可为 <code>null</code>，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>指定为 <code>String?</code> 类型后，可以为 <code>languageName</code>
赋值为 <code>String</code> 或 <code>null</code>。</p>
<h4 id="使用可为-null-的变量">使用可为 null 的变量</h4>
<h5 id="初始化为null">初始化为null：</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> favoriteSinger = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重新赋值为null">重新赋值为null</h5>
<p>错误例子： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    favoriteSinger = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 正确的写法： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger)</span><br><span class="line"></span><br><span class="line">    favoriteSinger = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="处理可为-null-的变量">处理可为 null 的变量</h4>
<p>继续上面的例子,如果我们想要访问可以为null的变量的属性，一个错误的例子如下：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个时候我们会遇到这样的报错： <img
src="/images/kotlin/image-2.png" alt="alt text" /> Kotlin
会刻意应用语法规则，以实现 <code>null</code> 安全，即保证不会意外调用
<code>null</code> 变量。但这并不表示变量不能为
<code>null</code>；而是表示，在访问某个变量的成员时，则该变量不能为
<code>null</code>。</p>
<p>如果在应用运行时访问 <code>null</code> 变量的成员（称为
<code>null</code> 引用），应用会因 <code>null</code>
变量不含任何属性或方法而崩溃。此类崩溃称为“运行时错误”，即在代码完成编译和运行后发生的错误。</p>
<p>由于 Kotlin 具有 <code>null</code> 安全特性，因此 Kotlin
编译器会对可为 <code>null</code> 类型强制执行 <code>null</code>
检查，以免发生此类运行时错误。“Null 检查”是指在访问变量并将其视为不可为
<code>null</code> 类型之前，检查该变量是否为 <code>null</code>
的过程。如果想将可为 <code>null</code> 的值用作不可为 <code>null</code>
类型，则需要明确执行 <code>null</code> 检查。</p>
<p>在此示例中，系统不允许直接引用 <code>favoriteSinger</code> 变量的
<code>length</code> 属性，因为该变量有可能是
<code>null</code>，因此代码在编译时失败。</p>
<p>接下来，将会介绍用来处理可为 <code>null</code>
类型的各种技巧和运算符。 ##### 使用 <code>?.</code> 安全调用运算符</p>
<p>可以使用 <code>?.</code> 安全调用运算符访问可为 null
变量的方法或属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nullable variable&gt; ?. &lt;method/property&gt;</span><br></pre></td></tr></table></figure>
<p>如需使用 <code>?.</code>
安全调用运算符访问方法或属性，请在变量名称后面添加 <code>?</code>
符号，并使用 <code>.</code> 表示法访问方法或属性。 <code>?.</code>
安全调用运算符可让更安全地访问可为 null 的变量，因为 Kotlin
编译器会阻止变量成员为访问 <code>null</code>
引用而进行的任何尝试，并针对访问的成员返回 <code>null</code>。</p>
<p>如需安全地访问可为 null 的 <code>favoriteSinger</code>
变量的属性，请按以下步骤操作：</p>
<ol type="1">
<li>在 <code>println()</code> 语句中，将 <code>.</code> 运算符替换为
<code>?.</code> 安全调用运算符：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger?.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>运行此程序，结果为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>将 <code>favoriteSinger</code> 变量重新赋予
<code>null</code>，然后运行此程序： <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger?.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行此程序，结果为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>也就说，如果尝试访问<code>null</code>变量的<code>length</code>属性，该程序也不会崩溃，只会返回<code>null</code></p>
<h5 id="使用-非-null-断言运算符">使用 <code>!!</code> 非 null
断言运算符</h5>
<p>还可以使用 <code>!!</code> 非 null 断言运算符来访问可为 null
的变量的方法或属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nullable variable&gt; !!. &lt;method/property&gt;</span><br></pre></td></tr></table></figure>
<p>需要在可为 null 的变量后面添加 <code>!!</code> 非 null
断言运算符，之后再跟 <code>.</code>
运算符，最后添加不含任何空格的方法或属性。顾名思义，如果使用
<code>!!</code> 非 null 断言运算符，即表示断言变量的值不是
<code>null</code>，无论该变量是否为该值都应如此。</p>
<p>与 <code>?.</code> 安全调用运算符不同，当可为 null 的变量确实为
<code>null</code> 时，使用 <code>!!</code> 非 null
断言运算符可能会导致系统抛出 <code>NullPointerException</code>
错误。因此，只有在变量始终为不可为 <code>null</code>
或设置了适当的异常处理时，才应使用该断言运算符。如果异常未得到处理，便会导致运行时错误。</p>
<p>如需使用 <code>!!</code> 非 <code>null</code> 断言运算符访问
<code>favoriteSinger</code> 变量的属性，请按以下步骤操作：</p>
<ol type="1">
<li>为 <code>favoriteSinger</code> 变量重新赋予喜爱歌手的名称，然后在
<code>println()</code> 语句中将 <code>?.</code> 安全调用运算符替换为
<code>!!</code> 非 null 断言运算符：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line">    println(favoriteSinger!!.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>运行此程序，然后验证输出是否符合预期：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>为 <code>favoriteSinger</code> 变量重新赋予
<code>null</code>，然后运行此程序：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line">    println(favoriteSinger!!.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会显示 <code>NullPointerException</code> 错误，内容如下：</p>
<figure>
<img src="/images/kotlin/image-3.png" alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>此 Kotlin 错误显示程序在执行期间崩溃。因此，除非确定变量不为
<code>null</code>，否则不建议使用 <code>!!</code> 非 null
断言运算符。</p>
<h5 id="使用-ifelse-条件">使用 <code>if/else</code> 条件</h5>
<p>可以在 <code>if/else</code> 条件中使用 <code>if</code> 分支来执行
<code>null</code> 检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nullable variable&gt; != null</span><br></pre></td></tr></table></figure>
<p>将 <code>null</code> 检查与 <code>if/else</code>
语句结合使用具有以下优点：</p>
<ul>
<li><code>nullableVariable != null</code> 表达式的 <code>null</code>
检查会被用作 <code>if</code> 条件。</li>
<li><code>if</code> 分支中会假定变量不可为
<code>null</code>。因此，在这个主体中，可以随意访问变量的方法或属性，就像变量是不可为
<code>null</code> 一般，而不必使用 <code>!!</code> 安全调用运算符。</li>
<li><code>else</code> 分支中会假定变量为
<code>null</code>。因此，在这个主体中，可以添加应在变量为
<code>null</code> 时运行的语句。<code>else</code> 分支是可选的。对
<code>null</code> 检查失败时，只能使用 <code>if</code> 条件来运行
<code>null</code> 检查，而不执行默认操作。</li>
</ul>
<p>如果有多行代码使用可为 <code>null</code> 的变量，那么将
<code>null</code> 检查与 <code>if</code>
条件搭配使用会更方便。相比之下，<code>?.</code>
安全调用运算符更适用于对可为 <code>null</code> 变量的单次引用。</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预期的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The number of characters in your favorite singer&#x27;s name is 5.</span><br></pre></td></tr></table></figure>
<p>请注意，由于会在 <code>null</code> 检查之后访问 <code>if</code>
分支中的 <code>length</code> 方法，因此可以直接使用 <code>.</code>
运算符访问名称的长度方法。同样，Kotlin 编译器知道
<code>favoriteSinger</code> 变量绝不可能为
<code>null</code>，因此允许直接访问属性。</p>
<p>可添加一个 <code>else</code> 分支，以处理歌手名称为 <code>null</code>
的情况：</p>
<p>在 <code>else</code> 分支的主体中，添加会接受
<code>You didn't input a name.</code> 字符串的 <code>println</code>
语句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;You didn&#x27;t input a name.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为 <code>favoriteSinger</code> 变量赋予
<code>null</code>，然后运行此程序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favoriteSinger: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favoriteSinger != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="subst">$&#123;favoriteSinger.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;You didn&#x27;t input a name.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出符合预期，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You didn&#x27;t input a name.</span><br></pre></td></tr></table></figure>
<h5 id="使用-elvis-运算符">使用 <code>?:</code> Elvis 运算符</h5>
<p><code>?:</code> Elvis 运算符可以与 <code>?.</code>
安全调用运算符搭配使用。如果搭配使用 <code>?:</code> Elvis
运算符，便可以在 <code>?.</code> 安全调用运算符返回 <code>null</code>
时添加默认值。这与 <code>if/else</code> 表达式类似，但更为常用。</p>
<p>如果该变量不为 <code>null</code>，则执行 <code>?.</code> Elvis
运算符之前的表达式；如果变量为 <code>null</code>，则执行 <code>?:</code>
Elvis 运算符之后的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &lt;name&gt; = &lt;nullable variable&gt; ?. &lt;method/property&gt; ?: &lt;default value&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>length</code> 属性之后，添加后跟的值 <code>0</code> 的
<code>?:</code> Elvis 运算符，然后运行此程序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> favoriteSinger: String? = <span class="string">&quot;milet&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lengthOfName = favoriteSinger?.length ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;The number of characters in your favorite singer&#x27;s name is <span class="variable">$lengthOfName</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出会与之前的输出相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The number of characters in your favorite singer&#x27;s name is 5.</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/07/20/android/" rel="next" title="Android介绍">
      Android介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#kotlin-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Kotlin 语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.0.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">1.0.2.</span> <span class="nav-text">类型推断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.1.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">while 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.3.1.</span> <span class="nav-text">简化函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">命名参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E5%9C%A8%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="nav-number">1.3.4.</span> <span class="nav-text">将函数存储在变量中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">使用 lambda
表达式重新定义函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">高阶函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.1.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">默认构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">定义形参化构造函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getter"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Getter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setter"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Setter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8E%E5%A4%87%E5%AD%97%E6%AE%B5"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">使用后备字段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.2.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">属性的可见性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">数据类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">创建子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">覆盖属性和方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">使用 super 关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">继承和构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">多继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null-%E5%AE%89%E5%85%A8"><span class="nav-number">1.5.</span> <span class="nav-text">Null 安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%B8%BA-null-%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用可为 null 的变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BAnull"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">初始化为null：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E4%B8%BAnull"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">重新赋值为null</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8F%AF%E4%B8%BA-null-%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">处理可为 null 的变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E9%9D%9E-null-%E6%96%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">使用 !! 非 null
断言运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ifelse-%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">使用 if&#x2F;else 条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-elvis-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">使用 ?: Elvis 运算符</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xuu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
